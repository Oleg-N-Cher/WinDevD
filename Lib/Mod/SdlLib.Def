(*Win32*)

MODULE SdlLib;
IMPORT SYSTEM, OS := SdlWin32;

(******************************************************************************)
(*																																						*)
(*		SDL for Oberon: interface modules for SDL - Simple DirectMedia Layer		*)
(*						Conversion of the Simple DirectMedia Layer headers							*)
(* for Oberon family languages: Oberon-2, Active Oberon and Component Pascal. *)
(*									 Supported SDL version 1.2.15 (stable)										*)
(*																																						*)
(* Based on JEDI-SDL by Dominique Louis																			 *)
(* Copyright (C) 2000-2004 Dominique Louis.																	 *)
(* http://sdl.delphi-jedi.org 																								*)
(*																																						*)
(* The initial developers of this Component Pascal code was:									*)
(* F. Necati Ecevit <fnecati [at] GYTE.EDU.TR>																*)
(* Oleg N. Cher <allot [at] bk.Ru>																						*)
(* "SDL for Oberon" website: http://sourceforge.net/projects/sdl-for-oberon/	*)
(*																																						*)
(* SDL created by Sam Lantinga <slouken [at] devolution.com> are							*)
(* Copyright (C) 1997-2004	Sam Lantinga																			*)
(* 5635-34 Springhouse Dr.																										*)
(* Pleasanton, CA 94588 (USA)																								 *)
(*																																						*)
(* All Rights Reserved.																											 *)
(*																																						*)
(* Requires																																	 *)
(* --------																																	 *)
(*	 The SDL Runtime library on Win32: SDL.dll 															 *)
(*	 It is available from http://www.libsdl.org 															*)
(*																																						*)
(******************************************************************************)

(******************************************************************************)
(*																																						*)
(* The original files are : SDL.h																						 *)
(*													SDL_main.h																				*)
(*													SDL_types.h																			 *)
(*													SDL_rwops.h																			 *)
(*													SDL_timer.h																			 *)
(*													SDL_audio.h																			 *)
(*													SDL_cdrom.h																			 *)
(*													SDL_joystick.h																		*)
(*													SDL_mouse.h																			 *)
(*													SDL_keyboard.h																		*)
(*													SDL_events.h																			*)
(*													SDL_video.h																			 *)
(*													SDL_byteorder.h																	 *)
(*													SDL_version.h																		 *)
(*													SDL_active.h																			*)
(*													SDL_thread.h																			*)
(*													SDL_mutex .h																			*)
(*													SDL_getenv.h																			*)
(*													SDL_loadso.h																			*)
(*																																						*)
(* The contents of this file are used with permission, subject to						 *)
(* the Mozilla Public License Version 1.1 (the "License"); you may						*)
(* not use this file except in compliance with the License. You may					 *)
(* obtain a copy of the License at																						*)
(* http://www.mozilla.org/MPL/MPL-1.1.html																		*)
(*																																						*)
(* Software distributed under the License is distributed on an								*)
(* "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or						 *)
(* implied. See the License for the specific language governing							 *)
(* rights and limitations under the License.																	*)
(*																																						*)
(* Requires																																	 *)
(* --------																																	 *)
(*	 The SDL Runtime libraris on Win32	: SDL.dll on Linux : libSDL.so				*)
(*	 They are available from...																							 *)
(*	 http://www.libsdl.org .																									*)
(*																																						*)
(******************************************************************************)

(* Revision History																													 *)
(* ----------------																													 *)
(*
	1.2.15a 2013/05/3
	Fix dll name in SdlImage. Added Docu/Sdl-Coder-List.odc,
		Sdl-Compile-List.odc, Sdl-Quick-Start.odc (thanks to Ivan Denisov).

	1.2.15 2013/01/23
	Added SDL_net support, some minor/major fixes, supported Linux i386+ (x32).

	Revision 0.11a 2012/04/08
	Exported PUInt8, PUInt16. Removed some idents without '_'.

	Revision 0.11	2011/01/22
	Added video, GL & joystick support, fixed bugs with unions, some minor fixes.

	Revision 0.10	2010/11/22
	Added mouse support.

	Revision 0.09	2010/11/19
	Added CD support, added SDL_image support, some minor fixes.

	Revision 0.07	2010/11/01
	Partially added audio support, some bugs fixed (thanks to Romiras).

	Revision 0.06	2010/10/31
	Partially added events support.

	Revision 0.05	2010/10/26
	Added SDL_gfx support. Thanks to F. Necati Ecevit.

	Module 1.0 release.
*)
(******************************************************************************) 
CONST
(* WINDOWS *)
	SDLLibName = "SDL.dll";
(* UNIX
	SDLLibName = "libSDL.so";
	SDLLibName = "libSDL-1.2.so.0";
*)

	(* SDL_verion.h constants *)
	VERSION* = "1.2.15";
	(* Printable format: "%d.%d.%d", MAJOR, MINOR, PATCHLEVEL *)
	MAJOR_VERSION* = 1;
	MINOR_VERSION* = 2;
	PATCHLEVEL* = 15;

	(* SDL.h constants *)
	INIT_TIMER* = {0};
	INIT_AUDIO* = {4};
	INIT_VIDEO* = {5};
	INIT_CDROM* = {8};
	INIT_JOYSTICK* = {9};
	INIT_NOPARACHUTE* = {20}; (* Don't catch fatal signals *)
	INIT_EVENTTHREAD* = {24}; (* Not supported on all OS's *)
	INIT_EVERYTHING* = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};

	(* SDL_error.h constants *)
	ERR_MAX_STRLEN* = 128;
	ERR_MAX_ARGS* = 5;

	(* SDL_types.h constants *)
	PRESSED* = 01H;
	RELEASED* = 00H;

	(* SDL_timer.h constants *)
	(* This is the OS scheduler timeslice, in milliseconds *)
	TIMESLICE* = 10;
	(* This is the maximum resolution of the SDL timer on all platforms *)
	TIMER_RESOLUTION* = 10; (* Experimentally determined *)

	(* SDL_audio.h constants *)
	AUDIO_U8* = 0008H; (* Unsigned 8-bit samples *)
	AUDIO_S8* = 8008H; (* Signed 8-bit samples *)
	AUDIO_U16LSB* = OS.AUDIO_U16LSB; (* Unsigned 16-bit samples *)
	AUDIO_S16LSB* = OS.AUDIO_S16LSB; (* Signed 16-bit samples *)
	AUDIO_U16MSB* = OS.AUDIO_U16MSB; (* As above, but big-endian byte order *)
	AUDIO_S16MSB* = OS.AUDIO_S16MSB; (* As above, but big-endian byte order *)
	AUDIO_U16* = AUDIO_U16LSB;
	AUDIO_S16* = AUDIO_S16LSB;

	(* SDL_cdrom.h constants *)
	(* The maximum number of CD-ROM tracks on a disk *)
	MAX_TRACKS* = 99;
	(* The types of CD-ROM track possible *)
	AUDIO_TRACK* = 00H;
	DATA_TRACK* = 04H;

	(* CDstatus contants *)
	CD_ERROR* = -1;
	CD_TRAYEMPTY* = 0;
	CD_STOPPED* = 1;
	CD_PLAYING* = 2;
	CD_PAUSED* = 3;

	(* Conversion functions from frames to Minute/Second/Frames and vice versa *)
	CD_FPS* = 75;

	(* SDL_byteorder.h constants *)
	(* The two types of endianness *)
	LIL_ENDIAN* = OS.LIL_ENDIAN;
	BIG_ENDIAN* = OS.BIG_ENDIAN;

	BYTEORDER* = OS.BYTEORDER;
	(* Native audio byte ordering *)
	AUDIO_U16SYS* = OS.AUDIO_U16SYS;
	AUDIO_S16SYS* = OS.AUDIO_S16SYS;

	MIX_MAXVOLUME* = 128;

	(* SDL_joystick.h constants *)
	MAX_JOYSTICKS* = 2; (* only 2 are supported in the multimedia API *)
	MAX_AXES* = 6; (* each joystick can have up to 6 axes *)
	MAX_BUTTONS* = 32; (* and 32 buttons *)
	AXIS_MIN* = -32768; (* minimum value for axis coordinate *)
	AXIS_MAX* = 32767; (* maximum value for axis coordinate *)
	JOY_AXIS_THRESHOLD* = (((AXIS_MAX) - (AXIS_MIN)) / 100); (* 1% motion *)
	(* JOY_BUTTON_FLAG(n)				(1<<n)	*)
	(* array to hold joystick ID values	*)
	(* static UInt				SYS_JoystickID[MAX_JOYSTICKS];	*)
	(* static JOYCAPS				SYS_Joystick[MAX_JOYSTICKS]; *)

	(* Get the current state of a POV hat on a joystick
		 The return value is one of the following positions: *)
	HAT_CENTERED* = {};
	HAT_UP*			 = {0};
	HAT_RIGHT*		= {1};
	HAT_DOWN*		 = {2};
	HAT_LEFT*		 = {3};
	HAT_RIGHTUP*	 = HAT_RIGHT + HAT_UP;
	HAT_RIGHTDOWN* = HAT_RIGHT + HAT_DOWN;
	HAT_LEFTUP*		= HAT_LEFT + HAT_UP;
	HAT_LEFTDOWN*	= HAT_LEFT + HAT_DOWN;

	(* SDL_events.h constants *)
	NOEVENT* = 0X; (* Unused (do not remove) *)
	ACTIVEEVENT* = 1X; (* Application loses/gains visibility *)
	KEYDOWN* = 2X; (* Keys pressed *)
	KEYUP* = 3X; (* Keys released *)
	MOUSEMOTION* = 4X; (* Mouse moved *)
	MOUSEBUTTONDOWN* = 5X; (* Mouse button pressed *)
	MOUSEBUTTONUP* = 6X; (* Mouse button released *)
	JOYAXISMOTION* = 7X; (* Joystick axis motion *)
	JOYBALLMOTION* = 8X; (* Joystick trackball motion *)
	JOYHATMOTION* = 9X; (* Joystick hat position change *)
	JOYBUTTONDOWN* = 0AX; (* Joystick button pressed *)
	JOYBUTTONUP* = 0BX; (* Joystick button released *)
	QUIT* = 0CX;
	QUITEV* = 0CX; (* User-requested quit (Changed due to procedure conflict) *)
	SYSWMEVENT* = 0DX; (* System specific event *)
	EVENT_RESERVEDA* = 0EX; (* Reserved for future use.. *)
	EVENT_RESERVED* = 0FX; (* Reserved for future use.. *)
	VIDEORESIZE* = 10X; (* User resized video mode *)
	VIDEOEXPOSE* = 11X; (* Screen needs to be redrawn *)
	EVENT_RESERVED2* = 12X; (* Reserved for future use.. *)
	EVENT_RESERVED3* = 13X; (* Reserved for future use.. *)
	EVENT_RESERVED4* = 14X; (* Reserved for future use.. *)
	EVENT_RESERVED5* = 15X; (* Reserved for future use.. *)
	EVENT_RESERVED6* = 16X; (* Reserved for future use.. *)
	EVENT_RESERVED7* = 17X; (* Reserved for future use.. *)
	(* Events Sdl.USEREVENT through Sdl.MAXEVENTS-1 are for your use *)
	USEREVENT* = 18X;
	(* This last event is only for bounding internal arrays *)
	(* It is the number of bits in the event mask datatype -- UInt32 *)
	NUMEVENTS* = 32;

	ALLEVENTS* = 0FFFFFFFFH;

	ACTIVEEVENTMASK* = ASH(1, ORD(ACTIVEEVENT));

	KEYDOWNMASK* = ASH(1, ORD(KEYDOWN));
	KEYUPMASK* = ASH(1, ORD(KEYUP));
	MOUSEMOTIONMASK* = ASH(1, ORD(MOUSEMOTION));
	MOUSEBUTTONDOWNMASK* = ASH(1, ORD(MOUSEBUTTONDOWN));
	MOUSEBUTTONUPMASK* = ASH(1, ORD(MOUSEBUTTONUP));
	MOUSEEVENTMASK* = ASH(1, ORD(MOUSEMOTION)) +
		ASH(1, ORD(MOUSEBUTTONDOWN)) +
		ASH(1, ORD(MOUSEBUTTONUP));
	JOYAXISMOTIONMASK* = ASH(1, ORD(JOYAXISMOTION));
	JOYBALLMOTIONMASK* = ASH(1, ORD(JOYBALLMOTION));
	JOYHATMOTIONMASK* = ASH(1, ORD(JOYHATMOTION));
	JOYBUTTONDOWNMASK* = ASH(1, ORD(JOYBUTTONDOWN));
	JOYBUTTONUPMASK* = ASH(1, ORD(JOYBUTTONUP));
	JOYEVENTMASK* = ASH(1, ORD(JOYAXISMOTION)) +
		ASH(1, ORD(JOYBALLMOTION)) +
		ASH(1, ORD(JOYHATMOTION)) +
		ASH(1, ORD(JOYBUTTONDOWN)) +
		ASH(1, ORD(JOYBUTTONUP));
	VIDEORESIZEMASK* = ASH(1, ORD(VIDEORESIZE));
	QUITMASK* = ASH(1, ORD(QUITEV));
	SYSWMEVENTMASK* = ASH(1, ORD(SYSWMEVENT));

	(* This procedure allows you to set the state of processing certain events.
		 If 'state' is set to SDL_IGNORE, that event will be automatically dropped
		 from the event queue and will not event be filtered.
		 If 'state' is set to SDL_ENABLE, that event will be processed normally.
		 If 'state' is set to SDL_QUERY, SDL_EventState() will return the
		 current processing state of the specified event. *)

	QUERY* = -1;
	IGNORE* = 0;
	DISABLE* = 0;
	ENABLE* = 1;

	(* SDL_keyboard.h constants *)
	(* This is the mask which refers to all hotkey bindings *)
	ALL_HOTKEYS* = 0FFFFFFFFH;

(* Enable/Disable keyboard repeat.	Keyboard repeat defaults to off.
	 'delay' is the initial delay in ms between the time when a key is
	 pressed, and keyboard repeat begins.
	 'interval' is the time in ms between keyboard repeat events. *)

	DEFAULT_REPEAT_DELAY* = 500;
	DEFAULT_REPEAT_INTERVAL* = 30;

	(* The keyboard syms have been cleverly chosen to map to ASCII *)
	K_UNKNOWN* = 0;
	K_FIRST* = 0;
	K_BACKSPACE* = 8;
	K_TAB* = 9;
	K_CLEAR* = 12;
	K_RETURN* = 13;
	K_PAUSE* = 19;
	K_ESCAPE* = 27;
	K_SPACE* = 32;
	K_EXCLAIM* = 33;
	K_QUOTEDBL* = 34;
	K_HASH* = 35;
	K_DOLLAR* = 36;
	K_AMPERSAND* = 38;
	K_QUOTE* = 39;
	K_LEFTPAREN* = 40;
	K_RIGHTPAREN* = 41;
	K_ASTERISK* = 42;
	K_PLUS* = 43;
	K_COMMA* = 44;
	K_MINUS* = 45;
	K_PERIOD* = 46;
	K_SLASH* = 47;
	K_0* = 48;
	K_1* = 49;
	K_2* = 50;
	K_3* = 51;
	K_4* = 52;
	K_5* = 53;
	K_6* = 54;
	K_7* = 55;
	K_8* = 56;
	K_9* = 57;
	K_COLON* = 58;
	K_SEMICOLON* = 59;
	K_LESS* = 60;
	K_EQUALS* = 61;
	K_GREATER* = 62;
	K_QUESTION* = 63;
	K_AT* = 64;

	(* Skip uppercase letters *)

	K_LEFTBRACKET* = 91;
	K_BACKSLASH* = 92;
	K_RIGHTBRACKET* = 93;
	K_CARET* = 94;
	K_UNDERSCORE* = 95;
	K_BACKQUOTE* = 96;
	K_a* = 97;
	K_b* = 98;
	K_c* = 99;
	K_d* = 100;
	K_e* = 101;
	K_f* = 102;
	K_g* = 103;
	K_h* = 104;
	K_i* = 105;
	K_j* = 106;
	K_k* = 107;
	K_l* = 108;
	K_m* = 109;
	K_n* = 110;
	K_o* = 111;
	K_p* = 112;
	K_q* = 113;
	K_r* = 114;
	K_s* = 115;
	K_t* = 116;
	K_u* = 117;
	K_v* = 118;
	K_w* = 119;
	K_x* = 120;
	K_y* = 121;
	K_z* = 122;
	K_DELETE* = 127;
	(* End of ASCII mapped keysyms *)

	(* International keyboard syms *)
	K_WORLD_0* = 160; (* 0xA0 *)
	K_WORLD_1* = 161;
	K_WORLD_2* = 162;
	K_WORLD_3* = 163;
	K_WORLD_4* = 164;
	K_WORLD_5* = 165;
	K_WORLD_6* = 166;
	K_WORLD_7* = 167;
	K_WORLD_8* = 168;
	K_WORLD_9* = 169;
	K_WORLD_10* = 170;
	K_WORLD_11* = 171;
	K_WORLD_12* = 172;
	K_WORLD_13* = 173;
	K_WORLD_14* = 174;
	K_WORLD_15* = 175;
	K_WORLD_16* = 176;
	K_WORLD_17* = 177;
	K_WORLD_18* = 178;
	K_WORLD_19* = 179;
	K_WORLD_20* = 180;
	K_WORLD_21* = 181;
	K_WORLD_22* = 182;
	K_WORLD_23* = 183;
	K_WORLD_24* = 184;
	K_WORLD_25* = 185;
	K_WORLD_26* = 186;
	K_WORLD_27* = 187;
	K_WORLD_28* = 188;
	K_WORLD_29* = 189;
	K_WORLD_30* = 190;
	K_WORLD_31* = 191;
	K_WORLD_32* = 192;
	K_WORLD_33* = 193;
	K_WORLD_34* = 194;
	K_WORLD_35* = 195;
	K_WORLD_36* = 196;
	K_WORLD_37* = 197;
	K_WORLD_38* = 198;
	K_WORLD_39* = 199;
	K_WORLD_40* = 200;
	K_WORLD_41* = 201;
	K_WORLD_42* = 202;
	K_WORLD_43* = 203;
	K_WORLD_44* = 204;
	K_WORLD_45* = 205;
	K_WORLD_46* = 206;
	K_WORLD_47* = 207;
	K_WORLD_48* = 208;
	K_WORLD_49* = 209;
	K_WORLD_50* = 210;
	K_WORLD_51* = 211;
	K_WORLD_52* = 212;
	K_WORLD_53* = 213;
	K_WORLD_54* = 214;
	K_WORLD_55* = 215;
	K_WORLD_56* = 216;
	K_WORLD_57* = 217;
	K_WORLD_58* = 218;
	K_WORLD_59* = 219;
	K_WORLD_60* = 220;
	K_WORLD_61* = 221;
	K_WORLD_62* = 222;
	K_WORLD_63* = 223;
	K_WORLD_64* = 224;
	K_WORLD_65* = 225;
	K_WORLD_66* = 226;
	K_WORLD_67* = 227;
	K_WORLD_68* = 228;
	K_WORLD_69* = 229;
	K_WORLD_70* = 230;
	K_WORLD_71* = 231;
	K_WORLD_72* = 232;
	K_WORLD_73* = 233;
	K_WORLD_74* = 234;
	K_WORLD_75* = 235;
	K_WORLD_76* = 236;
	K_WORLD_77* = 237;
	K_WORLD_78* = 238;
	K_WORLD_79* = 239;
	K_WORLD_80* = 240;
	K_WORLD_81* = 241;
	K_WORLD_82* = 242;
	K_WORLD_83* = 243;
	K_WORLD_84* = 244;
	K_WORLD_85* = 245;
	K_WORLD_86* = 246;
	K_WORLD_87* = 247;
	K_WORLD_88* = 248;
	K_WORLD_89* = 249;
	K_WORLD_90* = 250;
	K_WORLD_91* = 251;
	K_WORLD_92* = 252;
	K_WORLD_93* = 253;
	K_WORLD_94* = 254;
	K_WORLD_95* = 255; (* 0xFF *)

	(* Numeric keypad *)
	K_KP0* = 256;
	K_KP1* = 257;
	K_KP2* = 258;
	K_KP3* = 259;
	K_KP4* = 260;
	K_KP5* = 261;
	K_KP6* = 262;
	K_KP7* = 263;
	K_KP8* = 264;
	K_KP9* = 265;
	K_KP_PERIOD* = 266;
	K_KP_DIVIDE* = 267;
	K_KP_MULTIPLY* = 268;
	K_KP_MINUS* = 269;
	K_KP_PLUS* = 270;
	K_KP_ENTER* = 271;
	K_KP_EQUALS* = 272;

	(* Arrows + Home/End pad *)
	K_UP* = 273;
	K_DOWN* = 274;
	K_RIGHT* = 275;
	K_LEFT* = 276;
	K_INSERT* = 277;
	K_HOME* = 278;
	K_END* = 279;
	K_PAGEUP* = 280;
	K_PAGEDOWN* = 281;

	(* Function keys *)
	K_F1* = 282;
	K_F2* = 283;
	K_F3* = 284;
	K_F4* = 285;
	K_F5* = 286;
	K_F6* = 287;
	K_F7* = 288;
	K_F8* = 289;
	K_F9* = 290;
	K_F10* = 291;
	K_F11* = 292;
	K_F12* = 293;
	K_F13* = 294;
	K_F14* = 295;
	K_F15* = 296;

	(* Key state modifier keys *)
	K_NUMLOCK* = 300;
	K_CAPSLOCK* = 301;
	K_SCROLLOCK* = 302;
	K_RSHIFT* = 303;
	K_LSHIFT* = 304;
	K_RCTRL* = 305;
	K_LCTRL* = 306;
	K_RALT* = 307;
	K_LALT* = 308;
	K_RMETA* = 309;
	K_LMETA* = 310;
	K_LSUPER* = 311; (* Left "Windows" key *)
	K_RSUPER* = 312; (* Right "Windows" key *)
	K_MODE* = 313; (* "Alt Gr" key *)
	K_COMPOSE* = 314; (* Multi-key compose key *)

	(* Miscellaneous procedure keys *)
	K_HELP* = 315;
	K_PRINT* = 316;
	K_SYSREQ* = 317;
	K_BREAK* = 318;
	K_MENU* = 319;
	K_POWER* = 320; (* Power Macintosh power key *)
	K_EURO* = 321; (* Some european keyboards *)

(*$IFDEF GP2X*)
	K_GP2X_UP* = 0;
	K_GP2X_UPLEFT* = 1;
	K_GP2X_LEFT* = 2;
	K_GP2X_DOWNLEFT* = 3;
	K_GP2X_DOWN* = 4;
	K_GP2X_DOWNRIGHT* = 5;
	K_GP2X_RIGHT* = 6;
	K_GP2X_UPRIGHT* = 7;
	K_GP2X_START* = 8;
	K_GP2X_SELECT* = 9;
	K_GP2X_L* = 10;
	K_GP2X_R* = 11;
	K_GP2X_A* = 12;
	K_GP2X_B* = 13;
	K_GP2X_Y* = 14;
	K_GP2X_X* = 15;
	K_GP2X_VOLUP* = 16;
	K_GP2X_VOLDOWN* = 17;
	K_GP2X_CLICK* = 18;
(*$ENDIF*)

	(* Enumeration of valid key mods (possibly OR'd together) *)
	KMOD_NONE* = {};
	KMOD_LSHIFT* = {0};
	KMOD_RSHIFT* = {1};
	KMOD_LCTRL* = {6};
	KMOD_RCTRL* = {7};
	KMOD_LALT* = {8};
	KMOD_RALT* = {9};
	KMOD_LMETA* = {10};
	KMOD_RMETA* = {11};
	KMOD_NUM* = {12};
	KMOD_CAPS* = {13};
	KMOD_MODE* = {14};
	KMOD_RESERVED* = {15};

	KMOD_CTRL* = (KMOD_LCTRL + KMOD_RCTRL);
	KMOD_SHIFT* = (KMOD_LSHIFT + KMOD_RSHIFT);
	KMOD_ALT* = (KMOD_LALT + KMOD_RALT);
	KMOD_META* = (KMOD_LMETA + KMOD_RMETA);

	(* SDL_video.h constants *)
	(* Transparency definitions: These define alpha as the opacity of a surface *)
	ALPHA_OPAQUE* = 255;
	ALPHA_TRANSPARENT* = 0;

	(* These are the currently supported flags for the SDL_surface *)
	(* Available for SDL_CreateRGBSurface() or SDL_SetVideoMode() *)
	SWSURFACE* = {}; (* Surface is in system memory *)
	HWSURFACE* = {0}; (* Surface is in video memory *)
	ASYNCBLIT* = {2}; (* Use asynchronous blits if possible *)
	(* Available for SDL_SetVideoMode() *)
	ANYFORMAT* = {28}; (* Allow any video depth/pixel-format *)
	HWPALETTE* = {29}; (* Surface has exclusive palette *)
	DOUBLEBUF* = {30}; (* Set up double-buffered video mode *)
	FULLSCREEN* = {31}; (* Surface is a full screen display *)
	OPENGL* = {1}; (* Create an OpenGL rendering context *)
	OPENGLBLIT* = {1}; (* Create an OpenGL rendering context *)
	RESIZABLE* = {4}; (* This video mode may be resized *)
	NOFRAME* = {5}; (* No window caption or edge frame *)
	(* Used internally (read-only) *)
	HWACCEL* = {8}; (* Blit uses hardware acceleration *)
	SRCCOLORKEY* = {12}; (* Blit uses a source color key *)
	RLEACCELOK* = {13}; (* Private flag *)
	RLEACCEL* = {14}; (* Colorkey blit is RLE accelerated *)
	SRCALPHA* = {16}; (* Blit uses source alpha blending *)
	SRCCLIPPING* = {20}; (* Blit uses source clipping *)
	PREALLOC* = {24}; (* Surface uses preallocated memory *)

 (* The most common video overlay formats.
		For an explanation of these pixel formats, see:
		http://www.webartz.com/fourcc/indexyuv.htm

	 For information on the relationship between color spaces, see:
	 http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html *)

	YV12_OVERLAY* = 032315659H; (* Planar mode: Y + V + U	(3 planes) *)
	IYUV_OVERLAY* = 056555949H; (* Planar mode: Y + U + V	(3 planes) *)
	YUY2_OVERLAY* = 032595559H; (* Packed mode: Y0+U0+Y1+V0 (1 plane) *)
	UYVY_OVERLAY* = 059565955H; (* Packed mode: U0+Y0+V0+Y1 (1 plane) *)
	YVYU_OVERLAY* = 055595659H; (* Packed mode: Y0+V0+Y1+U0 (1 plane) *)

	(* flags for SDL_SetPalette() *)
	LOGPAL* = 01H;
	PHYSPAL* = 02H;

	(* SDL_mouse.h constants *)
	(* Used as a mask when testing buttons in buttonstate
			Button 1:	Left mouse button
			Button 2:	Middle mouse button
			Button 3:	Right mouse button
			Button 4:	Mouse Wheel Up (may also be a real button)
			Button 5:	Mouse Wheel Down (may also be a real button)
			Button 6:	Mouse X1 (may also be a real button)
			Button 7:	Mouse X2 (may also be a real button)
	*)
	BUTTON_LEFT*			= 1X;
	BUTTON_MIDDLE*		= 2X;
	BUTTON_RIGHT*		 = 3X;
	BUTTON_WHEELUP*	 = 4X;
	BUTTON_WHEELDOWN* = 5X;
	BUTTON_X1*				= 6X;
	BUTTON_X2*				= 7X;

	BUTTON_LMASK* = CHR(ASH(PRESSED, (ORD(BUTTON_LEFT) - 1)));
	BUTTON_MMASK* = CHR(ASH(PRESSED, (ORD(BUTTON_MIDDLE) - 1)));
	BUTTON_RMASK* = CHR(ASH(PRESSED, (ORD(BUTTON_RIGHT) - 1)));
	BUTTON_X1MASK* = CHR(ASH(PRESSED, (ORD(BUTTON_X1) - 1)));
	BUTTON_X2MASK* = CHR(ASH(PRESSED, (ORD(BUTTON_X2) - 1)));

	(* SDL_active.h constants *)
	(* The available application states *)
	APPMOUSEFOCUS* = 01H; (* The app has mouse coverage *)
	APPINPUTFOCUS* = 02H; (* The app has input focus *)
	APPACTIVE* = 04H; (* The application is active *)

	(* SDL_mutex.h constants *)
	(* Synchronization functions which can time out return this value *)
	(*	they time out. *)

	MUTEX_TIMEDOUT* = 1;

	(* This is the timeout value which corresponds to never time out *)
	MUTEX_MAXWAIT* = -1;

(*TSDL_GrabMode = (
		SDL_GRAB_QUERY,
		SDL_GRAB_OFF,
		SDL_GRAB_ON,
		SDL_GRAB_FULLSCREEN	); // Used internally *)
	GRAB_QUERY* = -1;
	GRAB_OFF*	 = 0;
	GRAB_ON*		= 1;
	(* GRAB_FULLSCREEN // Used internally *)

TYPE
	(* Delphi types *)
	Byte* 		= BYTE;
	Cardinal* = INTEGER;
	Char* 		= CHAR;
	Double* 	= LONGREAL; (* 64 bit *)
	Integer*	= INTEGER;
	LongWord* = Cardinal;
	PChar*		= SYSTEM.PTR;
	Pointer*	= SYSTEM.PTR;
	Single* 	= REAL; (* 32 bit *)
	Word*		 = SHORTINT; (* 16 bit *)

	Address*	= OS.Address; (* 32 bit system address *)

	(*THandle = Cardinal;*)
	(* SDL_types.h types *)
	(* Basic data types *)

	Bool* = Integer; (* SDL_FALSE, SDL_TRUE *)
	UInt8* = CHAR;
(*
	PUInt8Array = ^TUInt8Array;*)
	PUInt8* = SYSTEM.PTR;(*
	PPUInt8 = ^PUInt8;*)
(*
	TUInt8Array = array [0..MAXINT shr 1] of UInt8;
*)
	UInt16* = SHORTINT;
	PUInt16* = SYSTEM.PTR;
(*
	PSInt8 = ^SInt8;*)
	SInt8 = Byte;(*

	PSInt16 = ^SInt16;*)
	SInt16* = SHORTINT;

	UInt32* = INTEGER;
	PUInt32* = SYSTEM.PTR;

	SInt32* = Integer;
(*
	PInt = ^Integer;

	PShortInt = ^ShortInt;

	PUInt64 = ^UInt64;
	UInt64 = record
		hi: UInt32;
		lo: UInt32;
	end;
{-$EXTERNALSYM UInt64}

	PSInt64 = ^SInt64;
	SInt64 = record
		hi: UInt32;
		lo: UInt32;
	end;
{-$EXTERNALSYM SInt64}*)

	GrabMode = Integer;
(*
	// SDL_error.h types
	TSDL_errorcode = (
		SDL_ENOMEM,
		SDL_EFREAD,
		SDL_EFWRITE,
		SDL_EFSEEK,
		SDL_LASTERROR);

	SDL_errorcode = TSDL_errorcode;
{-$EXTERNALSYM SDL_errorcode}

	TArg = record
		case Byte of
			0: (value_ptr: Pointer);
			(* #if 0 means: never
			1 :	( value_c : Byte );
			*)
			2: (value_i: Integer);
			3: (value_f: double);
			4: (buf: array[0..ERR_MAX_STRLEN - 1] of Byte);
	end;

	PSDL_error = ^TSDL_error;
	TSDL_error = record
		{ This is a numeric value corresponding to the current error }
		error: Integer;

		{ This is a key used to index into a language hashtable containing
			 internationalized versions of the SDL error messages.	If the key
			 is not in the hashtable, or no hashtable is available, the key is
			 used directly as an error message format string. }
		key: array[0..ERR_MAX_STRLEN - 1] of Byte;

		{ These are the arguments for the error functions }
		argc: Integer;
		args: array[0..ERR_MAX_ARGS - 1] of TArg;
	end;
*)
	(* SDL_rwops.h types *)
	(* This is the read/write operation structure -- very basic *)
	(* some helper types to handle the unions *)
	(* "packed" is only guessed *)

	(* first declare the pointer types *)
	PRWops* = POINTER [1] TO RWops;
	(* now the pointer to procedure types *)
	(* the variant record itself *)
	RWops* = RECORD [1]
			(* Seek to 'offset' relative to whence, one of stdio's whence values:
			SEEK_SET, SEEK_CUR, SEEK_END
			Returns the final offset in the data source. *)
		seek*: PROCEDURE (
			context: PRWops; offset, whence: Integer): Integer;
			(* Read up to 'num' objects each of size 'objsize' from the data
			source to the area pointed at by 'ptr'.
			Returns the number of objects read, or -1 if the read failed. *)
		read*: PROCEDURE (
			context: PRWops; ptr: Pointer; size, maxnum: Integer): Integer;
			(* Write exactly 'num' objects each of size 'objsize' from the area
			pointed at by 'ptr' to data source.
			Returns 'num', or -1 if the write failed. *)
		write*: PROCEDURE (
			context: PRWops; ptr: Pointer; size, num: Integer): Integer;
			(* Close and free an allocated SDL_FSops structure *)
		close*: PROCEDURE (context: PRWops): Integer;
		(* CASE Integer OF *)
		type*: UInt32;
		(* be warned! structure alignment may arise at this point *)
		hidden-: RECORD [1](*[union]*)
			(* 0: stdio; *)
			stdio-: RECORD [1]
				autoclose-: Integer;
				fp-: Pointer;
			END;
			(* 1: mem; *)
			mem-: RECORD [1]
				base-: PUInt8;
				here-: PUInt8;
				stop-: PUInt8;
			END;
			(* 2: unknown; *)
			unknown-: RECORD [1]
				data1-: Pointer;
			END;
		END;
	END;

	(* SDL_timer.h types *)
	(* Function prototype for the timer callback function *)
	TimerCallback* = PROCEDURE (interval: UInt32): UInt32;

(* New timer API, supports multiple timers
	 Written by Stephane Peter <megastep@lokigames.com> *)

(* Function prototype for the new timer callback function.
	 The callback procedure is passed the current timer interval and returns
	 the next timer interval.	If the returned value is the same as the one
	 passed in, the periodic alarm continues, otherwise a new alarm is
	 scheduled.	If the callback returns 0, the periodic alarm is cancelled. *)
	NewTimerCallback* = PROCEDURE (
		interval: UInt32; param: Pointer): UInt32;
	
	(* Definition of the timer ID type *)
	PTimerID* = POINTER [1] TO TimerID;
	TimerID* = RECORD [1]
		interval*: UInt32;
		callback*: NewTimerCallback;
		param*: Pointer;
		last_alarm*: UInt32;
		next*: PTimerID;
	END;

	AudioSpecCallback* = PROCEDURE (
		userdata: Pointer; VAR stream: UInt8; len: Integer);

	(* SDL_audio.h types *)
	(* The calculated values in this structure are calculated by OpenAudio() *)
	PAudioSpec* = POINTER [1] TO AudioSpec;
	AudioSpec* = RECORD [1]
		freq*: Integer; (* DSP frequency -- samples per second *)
		format*: UInt16; (* Audio data format *)
		channels*: UInt8; (* Number of channels: 1 mono, 2 stereo *)
		silence*: UInt8; (* Audio buffer silence value (calculated) *)
		samples*: UInt16; (* Audio buffer size in samples *)
		padding*: UInt16; (* Necessary for some compile environments *)
		size*: UInt32; (* Audio buffer size in bytes (calculated) *)
		(* This procedure is called when the audio device needs more data.
			 'stream' is a pointer to the audio data buffer
			 'len' is the length of that buffer in bytes.
			 Once the callback returns, the buffer will no longer be valid.
			 Stereo samples are stored in a LRLRLR ordering. *)
		callback*: AudioSpecCallback;
		userdata*: Pointer;
	END;

	(* A structure to hold a set of audio conversion filters and buffers *)
	PAudioCVT* = POINTER [1] TO AudioCVT;

	PAudioCVTFilter* = POINTER [1] TO AudioCVTFilter;
	AudioCVTFilter* = RECORD [1]
		cvt*: PAudioCVT;
		format*: UInt16;
	END;

	PAudioCVTFilterArray* = POINTER [1] TO AudioCVTFilterArray;
	AudioCVTFilterArray = ARRAY 10 OF PAudioCVTFilter;

	AudioCVT* = RECORD [1]
		needed*: Integer; (* Set to 1 if conversion possible *)
		src_format*: UInt16; (* Source audio format *)
		dst_format*: UInt16; (* Target audio format *)
		rate_incr*: Double; (* Rate conversion increment *)
		buf*: PUInt8; (* Buffer to hold entire audio data *)
		len*: Integer; (* Length of original audio buffer *)
		len_cvt*: Integer; (* Length of converted audio buffer *)
		len_mult*: Integer; (* buffer must be len*len_mult big *)
		len_ratio*: Double; (* Given len, final size is len*len_ratio *)
		filters*: AudioCVTFilterArray;
		filter_index: Integer; (* Current audio conversion function *)
	END;

	AudioStatus* = UInt32 (*
		SDL_AUDIO_STOPPED,
		SDL_AUDIO_PLAYING,
		SDL_AUDIO_PAUSED
		*);

	(* SDL_cdrom.h types *)
	CDstatus* = UInt32 (*
		CD_ERROR,
		CD_TRAYEMPTY,
		CD_STOPPED,
		CD_PLAYING,
		CD_PAUSED *);

	PCDTrack* = POINTER [1] TO CDTrack;
	CDTrack* = RECORD [1]
		id-: UInt8; (* Track number *)
		type-: UInt8; (* Data or audio track *)
		unused-: UInt16;
		length-: UInt32; (* Length, in frames, of this track *)
		offset-: UInt32; (* Offset, in frames, from start of disk *)
	END;

	(* This structure is only current as of the last call to SDL_CDStatus() *)
	PCD* = POINTER [1] TO CD;
	CD* = RECORD [1]
		id: Integer; (* Private drive identifier *)
		status: CDstatus; (* Current drive status *)

		(* The rest of this structure is only valid if there's a CD in drive *)
		numtracks-: Integer; (* Number of tracks on disk *)
		cur_track-: Integer; (* Current track position *)
		cur_frame-: Integer; (* Current frame offset within current track *)
		track-: ARRAY MAX_TRACKS + 1 OF CDTrack;
	END;

	(* SDL_joystick.h types *)
	PTransAxis* = POINTER [1] TO TransAxis;
	TransAxis* = RECORD [1]
		offset*: Integer;
		scale*: Single;
	END;

	(* The private structure used to keep track of a joystick *)
	PJoystickHWdata* = POINTER [1] TO JoystickHWdata;
	JoystickHWdata* = RECORD [1]
		(* joystick ID *)
		id-: Integer;
		(* values used to translate device-specific coordinates into	SDL-standard ranges *)
		transaxis-: ARRAY 6 OF TransAxis;
	END;

	PBallDelta* = POINTER [1] TO BallDelta;
	BallDelta* = RECORD [1]
		dx*: Integer;
		dy*: Integer;
	END; (* Current ball motion deltas *)

	(* The SDL joystick structure *)
	PJoystick* = POINTER [1] TO Joystick;
	Joystick* = RECORD [1]
		index-: UInt8; (* Device index *)
		name-: PChar; (* Joystick name - system dependent *)

		naxes-: Integer; (* Number of axis controls on the joystick *)
		axes-: PUInt16; (* Current axis states *)

		nhats-: Integer; (* Number of hats on the joystick *)
		hats-: PUInt8; (* Current hat states *)

		nballs-: Integer; (* Number of trackballs on the joystick *)
		balls-: PBallDelta; (* Current ball motion deltas *)

		nbuttons-: Integer; (* Number of buttons on the joystick *)
		buttons-: PUInt8; (* Current button states *)

		hwdata-: PJoystickHWdata; (* Driver dependent information *)

		ref_count-: Integer; (* Reference count for multiple opens *)
	END;

	(* SDL_verion.h types *)
	PVersion* = POINTER [1] TO Version;
	Version* = OS.Version;

	(* SDL_keyboard.h types *)
	Key = LongWord;

	Mod = SET;

	PKeySym* = POINTER [1] TO KeySym;
	KeySym* = RECORD [1]
		scancode-: UInt8; (* hardware specific scancode *)
		sym-: Key; (* SDL virtual keysym *)
		modifier-: Mod; (* current key modifiers *)
		unicode-: UInt16; (* translated character *)
	END;

	(* SDL_events.h types *)
	(*Checks the event queue for messages and optionally returns them.
	 If 'action' is SDL_ADDEVENT, up to 'numevents' events will be added to
	 the back of the event queue.
	 If 'action' is SDL_PEEKEVENT, up to 'numevents' events at the front
	 of the event queue, matching 'mask', will be returned and will not
	 be removed from the queue.
	 If 'action' is SDL_GETEVENT, up to 'numevents' events at the front
	 of the event queue, matching 'mask', will be returned and will be
	 removed from the queue.
	 This procedure returns the number of events actually stored, or -1
	 if there was an error.	This procedure is thread-safe. *)

	EventAction* = Integer (* (SDL_ADDEVENT, SDL_PEEKEVENT, SDL_GETEVENT) *);

	(* Application visibility event structure *)
	ActiveEvent* = RECORD [1]
		type-: SInt8;	(* SDL_ACTIVEEVENT *)
		gain-: UInt8;	(* Whether given states were gained or lost (1/0) *)
		state-: UInt8; (* A mask of the focus states *)
	END;

	(* Keyboard event structure *)
	KeyboardEvent* = RECORD [1]
		type-: SInt8;	(* SDL_KEYDOWN or SDL_KEYUP *)
		which-: UInt8; (* The keyboard device index *)
		state-: UInt8; (* SDL_PRESSED or SDL_RELEASED *)
		keysym-: KeySym;
	END;

	(* Mouse motion event structure *)
	MouseMotionEvent* = RECORD [1]
		type-: SInt8;	(* SDL_MOUSEMOTION *)
		which-: UInt8; (* The mouse device index *)
		state-: UInt8; (* The current button state *)
		x-, y-: UInt16;(* The X/Y coordinates of the mouse *)
		xrel-: SInt16; (* The relative motion in the X direction *)
		yrel-: SInt16; (* The relative motion in the Y direction *)
	END;

	(* Mouse button event structure *)
	MouseButtonEvent* = RECORD [1]
		type-: SInt8;	 (* SDL_MOUSEBUTTONDOWN or SDL_MOUSEBUTTONUP *)
		which-: UInt8;	(* The mouse device index *)
		button-: UInt8; (* The mouse button index *)
		state-: UInt8;	(* SDL_PRESSED or SDL_RELEASED *)
		x-: UInt16;		 (* The X coordinates of the mouse at press time *)
		y-: UInt16;		 (* The Y coordinates of the mouse at press time *)
	END;

	(* Joystick axis motion event structure *)
	JoyAxisEvent* = RECORD [1]
		type-: SInt8;	(* SDL_JOYAXISMOTION *)
		which-: UInt8; (* The joystick device index *)
		axis-: UInt8;	(* The joystick axis index *)
		value-: SInt16;(* The axis value (range: -32768 to 32767) *)
	END;

	(* Joystick trackball motion event structure *)
	JoyBallEvent* = RECORD [1]
		type-: SInt8;	(* SDL_JOYAVBALLMOTION *)
		which-: UInt8; (* The joystick device index *)
		ball-: UInt8;	(* The joystick trackball index *)
		xrel-: SInt16; (* The relative motion in the X direction *)
		yrel-: SInt16; (* The relative motion in the Y direction *)
	END;

	(* Joystick hat position change event structure *)
	JoyHatEvent* = RECORD [1]
		type-: SInt8;	(* SDL_JOYHATMOTION *)
		which-: UInt8; (* The joystick device index *)
		hat-: UInt8;	 (* The joystick hat index *)
		value-: UInt8; (* The hat position value:
										8	 1	 2
										7	 0	 3
										6	 5	 4

										Note that zero means the POV is centered. *)

	END;

	(* Joystick button event structure *)
	JoyButtonEvent* = RECORD [1]
		type-: SInt8;	(* SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP *)
		which-: UInt8; (* The joystick device index *)
		button-: UInt8;(* The joystick button index *)
		state-: UInt8; (* SDL_PRESSED or SDL_RELEASED *)
	END;

	(* The "window resized" event
		 When you get this event, you are responsible for setting a new video
		 mode with the new width and height. *)
	ResizeEvent* = RECORD [1]
		type-: SInt8; (* SDL_VIDEORESIZE *)
		w-: Integer;	(* New width *)
		h-: Integer;	(* New height *)
	END;

	(* The "quit requested" event *)
	PQuitEvent* = POINTER [1] TO QuitEvent;
	QuitEvent* = RECORD [1]
		type-: SInt8;
	END;

	(* A user-defined event type *)
	PUserEvent* = POINTER [1] TO UserEvent;
	UserEvent* = RECORD [1]
		type-: SInt8;		(* SDL_USEREVENT through SDL_NUMEVENTS-1 *)
		code*: Integer;	(* User defined event code *)
		data1*: Pointer; (* User defined data pointer *)
		data2*: Pointer; (* User defined data pointer *)
	END;

	(* The "screen redraw" event *)
	PExposeEvent* = POINTER [1] TO ExposeEvent;
	ExposeEvent* = RECORD [1]
		type-: SInt8;	(* SDL_VIDEOEXPOSE *)
	END;
(*
 {$IFDEF Unix}
 //These are the various supported subsystems under UNIX
	TSDL_SysWm = ( SDL_SYSWM_X11 ) ;
 {$ENDIF}
*)
(*-$IFDEF WINDOWS*)
	PSysWMmsg* = OS.PSysWMmsg;
	SysWMmsg* = OS.SysWMmsg;
(*
{$ELSE}

{$IFDEF Unix}
{ The Linux custom event structure }
	PSDL_SysWMmsg = ^TSDL_SysWMmsg;
	TSDL_SysWMmsg = record
		version : TSDL_version;
		subsystem : TSDL_SysWm;
		{$IFDEF FPC}
		{$IFNDEF GP2X}
		{$IFNDEF DARWIN}
		{$IFNDEF SKYOS}
		event : TXEvent;
		{$ENDIF}
		{$ENDIF}
		{$ENDIF}
		{$ELSE}
		event : XEvent;
		{$ENDIF}
	end;
{$ELSE}
{ The generic custom event structure }
	PSDL_SysWMmsg = ^TSDL_SysWMmsg;
	TSDL_SysWMmsg = record
		version: TSDL_version;
		data: Integer;
	end;
{$ENDIF}

{$ENDIF}

// The Windows custom window manager information structure
{$IFDEF WINDOWS}
*)
	PSysWMinfo = OS.PSysWMinfo;
	SysWMinfo = OS.SysWMinfo;
(*
{$ELSE}

// The Linux custom window manager information structure
{$IFDEF Unix}
	{$IFNDEF GP2X}
	{$IFNDEF DARWIN}
	{$IFNDEF SKYOS}
	TX11 = record
		display : PDisplay;	// The X11 display
		window : TWindow ;		// The X11 display window */
		{* These locking functions should be called around
			 any X11 functions using the display variable.
			 They lock the event thread, so should not be
			 called around event functions or from event filters.
		 *}
		lock_func : Pointer;
		unlock_func : Pointer;

		// Introduced in SDL 1.0.2
		fswindow : TWindow ;	// The X11 fullscreen window */
		wmwindow : TWindow ;	// The X11 managed input window */
	end;
	{$ENDIF}
	{$ENDIF}
	{$ENDIF}
	
	PSDL_SysWMinfo = ^TSDL_SysWMinfo;
	TSDL_SysWMinfo = record
		 version : TSDL_version ;
		 subsystem : TSDL_SysWm;
		 {$IFNDEF GP2X}
		 {$IFNDEF DARWIN}
		 {$IFNDEF SKYOS}
		 X11 : TX11;
		 {$ENDIF}
		 {$ENDIF}
		 {$ENDIF}
	end;
{$ELSE}
	// The generic custom window manager information structure
	PSDL_SysWMinfo = ^TSDL_SysWMinfo;
	TSDL_SysWMinfo = record
		version : TSDL_version ;
		data : integer;
	end;
{$ENDIF}

{$ENDIF}
*)
	PSysWMEvent* = POINTER [1] TO SysWMEvent;
	SysWMEvent* = RECORD [1]
		type-: SInt8;
		msg-: OS.PSysWMmsg;
	END;

	(* General event structure *)
	PEvent* = POINTER [1] TO Event;
  Event* = RECORD [1]
    type-: Char;
    dummy: ARRAY [1] 32 OF CHAR; (* BB shows: SIZE(Sdl.Event) = 20 *)
  END;
(*
	Event* = RECORD [1](*[union]*)
		type-: Char;
		active*: ActiveEvent;
		key*: KeyboardEvent;
		motion*: MouseMotionEvent;
		button*: MouseButtonEvent;
		jaxis*: JoyAxisEvent;
		jball*: JoyBallEvent;
		jhat*: JoyHatEvent;
		jbutton*: JoyButtonEvent;
		resize*: ResizeEvent;
		expose*: ExposeEvent;
		quit*: QuitEvent;
		user*: UserEvent;
		syswm*: SysWMEvent;
	END;
*)
(* This procedure sets up a filter to process all events before they
	 change internal state and are posted to the internal event queue.

	The filter is protypted as: *)

	EventFilter* = PROCEDURE (event: PEvent): Integer;

	(* SDL_video.h types *)
	(* Useful data types *)
	(* PPSDL_Rect = ^PSDL_Rect; *)
	PRect* = POINTER [1] TO Rect;
	PPRect* = POINTER [1] TO ARRAY [1] OF PRect;
	Rect* = RECORD [1]
		x*, y*: SInt16;
		w*, h*: UInt16;
	END;

	PColor* = POINTER [1] TO Color;
	Color* = RECORD [1]
		r*: UInt8;
		g*: UInt8;
		b*: UInt8;
		unused*: UInt8;
	END;

	PColorArray* = POINTER [1] TO ColorArray;
	ColorArray* = ARRAY [1] 65000+1 OF Color;

	PPalette* = POINTER [1] TO Palette;
	Palette* = RECORD [1]
		ncolors*: Integer;
		colors*: PColorArray;
	END;

	(* Everything in the pixel format structure is read-only *)
	PPixelFormat* = POINTER [1] TO PixelFormat;
	PixelFormat* = RECORD [1]
		palette-: PPalette;
		BitsPerPixel-: Byte;
		BytesPerPixel-: Byte;
		Rloss-: UInt8;
		Gloss-: UInt8;
		Bloss-: UInt8;
		Aloss-: UInt8;
		Rshift-: UInt8;
		Gshift-: UInt8;
		Bshift-: UInt8;
		Ashift-: UInt8;
		Rmask-: UInt32;
		Gmask-: UInt32;
		Bmask-: UInt32;
		Amask-: UInt32;
		colorkey-: UInt32; (* RGB color key information *)
		alpha-: UInt8; (* Alpha value information (per-surface alpha) *)
	END;

(*$IFDEF WINDOWS}
	{PPrivate_hwdata = ^TPrivate_hwdata;
	TPrivate_hwdata = record
		dd_surface : IDIRECTDRAWSURFACE3;
		dd_writebuf : IDIRECTDRAWSURFACE3;
	end;}
	{ELSE}
{$ENDIF*)

	(* The structure passed to the low level blit functions *)
	PBlitInfo* = POINTER [1] TO BlitInfo;
	BlitInfo* = RECORD [1]
		s_pixels*: PUInt8;
		s_width*: Integer;
		s_height*: Integer;
		s_skip*: Integer;
		d_pixels*: PUInt8;
		d_width*: Integer;
		d_height*: Integer;
		d_skip*: Integer;
		aux_data*: Pointer;
		src*: PPixelFormat;
		table*: PUInt8;
		dst*: PPixelFormat;
	END;

	(* typedef for private surface blitting functions *)
	PSurface* = POINTER [1] TO Surface;

	Blit* = PROCEDURE (src: PSurface; srcrect: PRect;
														 dst: PSurface; dstrect: PRect): Integer;
(*
	(* The type definition for the low level blit functions *)
	(*TSDL_LoBlit = procedure( info : PSDL_BlitInfo ); cdecl; *)

	(* This is the private info structure for software accelerated blits *)
	{PPrivate_swaccel = ^TPrivate_swaccel;
	TPrivate_swaccel = record
		blit : TSDL_LoBlit;
		aux_data : Pointer;
	end;}

	// Blit mapping definition
	{PSDL_BlitMap = ^TSDL_BlitMap;
	TSDL_BlitMap = record
		dst : PSDL_Surface;
		identity : Integer;
		table : PUInt8;
		hw_blit : TSDL_Blit;
		sw_blit : TSDL_Blit;
		hw_data : PPrivate_hwaccel;
		sw_data : PPrivate_swaccel;

		// the version count matches the destination; mismatch indicates an invalid mapping
		format_version : Cardinal;
	end;}
*)
	Surface* = RECORD [1]
		flags-: SET; (* Read-only *)
		format-: PPixelFormat; (* Read-only *)
		w-, h-: Integer; (* Read-only *)
		pitch-: UInt16; (* Read-only *)
		pixels*: Pointer; (* Read-write *)
		offset-: Integer; (* Private *)
		hwdata-: Pointer; (* TPrivate_hwdata; Hardware-specific surface info *)

		(* clipping information: *)
		clip_rect-: Rect; (* Read-only *)
		unused1: UInt32; (* for binary compatibility *)
		(* Allow recursive locks *)
		locked-: UInt32; (* Private *)
		(* info for fast blit mapping to other surfaces *)
		map-: Pointer; (* Sdl.PBlitMap; Private *)
		(* format version, bumped at every change to invalidate blit maps *)
		format_version-: Cardinal; (* Private *)
		refcount-: Integer;
	END;

	(* Useful for determining the video hardware capabilities *)
	PVideoInfo* = POINTER [1] TO VideoInfo;
	VideoInfo* = RECORD [1]
		hw_available*: UInt8; (* Hardware and WindowManager flags in first 2 bits ( see below ) *)
		(*hw_available: 1; // Can you create hardware surfaces
		wm_available: 1; // Can you talk to a window manager?
		UnusedBits1: 6;*)
		blit_hw*: UInt8; (* Blit Hardware flags. See below for which bits do what *)
		(*UnusedBits2: 1;
		blit_hw: 1; // Flag:UInt32	Accelerated blits HW --> HW
		blit_hw_CC: 1; // Flag:UInt32	Accelerated blits with Colorkey
		blit_hw_A: 1; // Flag:UInt32	Accelerated blits with Alpha
		blit_sw: 1; // Flag:UInt32	Accelerated blits SW --> HW
		blit_sw_CC: 1; // Flag:UInt32	Accelerated blits with Colorkey
		blit_sw_A: 1; // Flag:UInt32	Accelerated blits with Alpha
		blit_fill: 1; // Flag:UInt32	Accelerated color fill*)
		UnusedBits3*: UInt8; (* Unused at this point *)
		video_mem*: UInt32; (* The total amount of video memory (in K) *)
		vfmt*: PPixelFormat; (* Value: The format of the video surface *)
		current_w* : SInt32;	(* Value: The current video mode width *)
		current_h* : SInt32;	(* Value: The current video mode height *)
	END;

	(* The YUV hardware video overlay *)
	POverlay* = POINTER [1] TO Overlay;
	Overlay* = RECORD [1]
		format*: UInt32; (* Overlay format *)
		w*, h*: Integer; (* Width and height of overlay *)
		planes*: Integer; (* Number of planes in the overlay. Usually either 1 or 3 *)
		pitches*: PUInt16;
			(* An array of pitches, one for each plane. Pitch is the length of a row in bytes. *)
		pixels*: Pointer; (* PPUInt8 *)
			(* An array of pointers to the data of each plane. The overlay should be locked before these pointers are used. *)
		hw_overlay*: UInt32;
			(* This will be set to 1 if the overlay is hardware accelerated. *)
	END;

	(* Public enumeration for setting the OpenGL window attributes. *)
	GLAttr* = Integer; (*
		SDL_GL_RED_SIZE,
		SDL_GL_GREEN_SIZE,
		SDL_GL_BLUE_SIZE,
		SDL_GL_ALPHA_SIZE,
		SDL_GL_BUFFER_SIZE,
		SDL_GL_DOUBLEBUFFER,
		SDL_GL_DEPTH_SIZE,
		SDL_GL_STENCIL_SIZE,
		SDL_GL_ACCUM_RED_SIZE,
		SDL_GL_ACCUM_GREEN_SIZE,
		SDL_GL_ACCUM_BLUE_SIZE,
		SDL_GL_ACCUM_ALPHA_SIZE,
		SDL_GL_STEREO,
		SDL_GL_MULTISAMPLEBUFFERS,
		SDL_GL_MULTISAMPLESAMPLES,
		SDL_GL_ACCELERATED_VISUAL,
		SDL_GL_SWAP_CONTROL);*)

	PCursor* = POINTER [1] TO Cursor;
	Cursor* = RECORD [1]
		area*: Rect; (* The area of the mouse cursor *)
		hot_x*, hot_y*: SInt16; (* The "tip" of the cursor *)
		data*: PUInt8; (* B/W cursor data *)
		mask*: PUInt8; (* B/W cursor mask *)
		save*: ARRAY 2 OF PUInt8; (* Place to save cursor area *)
		wm_cursor*: Pointer; (* Window-manager cursor *)
	END;
(*
(* SDL_mutex.h types *)

{$IFDEF WINDOWS}
	PSDL_Mutex = ^TSDL_Mutex;
	TSDL_Mutex = record
		id: THANDLE;
	end;
{$ENDIF}

{$IFDEF Unix}
	PSDL_Mutex = ^TSDL_Mutex;
	TSDL_mutex = record
		id: pthread_mutex_t;
{$IFDEF PTHREAD_NO_RECURSIVE_MUTEX}
		recursive: Integer;
		owner: pthread_t;
{$ENDIF}
	end;
{$ENDIF}

{$IFDEF NDS}
	PSDL_mutex = ^TSDL_Mutex;
	TSDL_Mutex = record
		recursive: Integer;
		Owner: UInt32;
		sem: PSDL_sem;
	end;
{$ENDIF}

{$IFDEF __MACH__}
	{$define USE_NAMED_SEMAPHORES}
	// Broken sem_getvalue() in MacOS X Public Beta */
	{$define BROKEN_SEMGETVALUE}
{$ENDIF}

PSDL_semaphore = ^TSDL_semaphore;
{$IFDEF WINDOWS}
	// WINDOWS or Machintosh
	TSDL_semaphore = record
		id: THANDLE;
		count: UInt32;
	end;
{$ELSE}
	{$IFDEF FPC}
	// This should be semaphore.h 
	__sem_lock_t = {packed} record { Not in header file - anonymous }
		status: Longint;
		spinlock: Integer;
	end;

	sem_t = {packed} record
		__sem_lock: __sem_lock_t;
		__sem_value: Integer;
		__sem_waiting: longint ; {_pthread_queue;}
	end;
	{$ENDIF}
	
	TSDL_semaphore = record
		sem: Pointer; //PSem_t;
	{$IFNDEF USE_NAMED_SEMAPHORES}
		sem_data: Sem_t;
	{$ENDIF}

	{$IFDEF BROKEN_SEMGETVALUE}
		{ This is a little hack for MacOS X -
			It's not thread-safe, but it's better than nothing }
		sem_value: Integer;
	{$ENDIF}
	end;
{$ENDIF}

	PSDL_Sem = ^TSDL_Sem;
	TSDL_Sem = TSDL_Semaphore;

	PSDL_Cond = ^TSDL_Cond;
	TSDL_Cond = record
{$IFDEF Unix}
		cond: pthread_cond_t;
{$ELSE}
		// Generic Cond structure
		lock: PSDL_mutex;
		waiting: Integer;
		signals: Integer;
		wait_sem: PSDL_Sem;
		wait_done: PSDL_Sem;
{$ENDIF}
	end;

	// SDL_thread.h types
{$IFDEF WINDOWS}
	TSYS_ThreadHandle = THandle;
{$ENDIF}

{$IFDEF Unix}
	TSYS_ThreadHandle = pthread_t;
{$ENDIF}

{$IFDEF NDS}
	TSYS_ThreadHandle = Integer;
{$ENDIF}

	{ This is the system-independent thread info structure }
	PSDL_Thread = ^TSDL_Thread;
	TSDL_Thread = record
		threadid: UInt32;
		handle: TSYS_ThreadHandle;
		status: Integer;
		errbuf: TSDL_Error;
		data: Pointer;
	end;

	// Helper Types

	// Keyboard	State Array ( See demos for how to use )
	PKeyStateArr = ^TKeyStateArr;
	TKeyStateArr = array[0..65000] of UInt8;
*)
	(* Types required so we don't need to use WinApi *)
	PInteger* = POINTER [1] TO ARRAY [1] OF Integer;
	PByte* = POINTER [1] TO ARRAY [1] OF Byte;
	PWord* = POINTER [1] TO ARRAY [1] OF Word;
	PLongWord* = POINTER [1] TO ARRAY [1] OF LongWord;
(*
	// General arrays
	PByteArray = ^TByteArray;
	TByteArray = array[0..32767] of Byte;

	PWordArray = ^TWordArray;
	TWordArray = array[0..16383] of Word;

	PPoint = ^TPoint;
	{$IFDEF HAS_TYPES}
	TPoint = Types.TPoint;
	{$ELSE}
		{$IFDEF WINDOWS}
			{$IFDEF __GPC__}
			TPoint = wintypes.TPoint;
			{$ELSE}
			TPoint = Windows.TPoint;
			{$ENDIF}
		{$ELSE}
			//Can't define TPoint : neither Types nor Windows unit available.
		{$ENDIF}
	{$ENDIF}

	PRect = ^TRect;
	{$IFDEF HAS_TYPES}
	TRect = Types.TRect;
	{$ELSE}
		{$IFDEF WINDOWS}
			{$IFDEF __GPC__}
			TRect = wintypes.TRect;
			{$ELSE}
			TRect = Windows.TRect;
			{$ENDIF}
		{$ELSE}
			//Can't define TRect: neither Types nor Windows unit available.
		{$ENDIF}
	{$ENDIF}

	{ Generic procedure pointer }
	TProcedure = procedure;
*)
(*----------------------------------------------------------------------------*)
(*															 Initialization 															*)
(*----------------------------------------------------------------------------*)

(* This procedure loads the SDL dynamically linked library and initializes
	 the subsystems specified by 'flags' (and those satisfying dependencies)
	 Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
	 signal handlers for some commonly ignored fatal signals (like SIGSEGV) *)

PROCEDURE -SDL_Init* (flags: SET): Integer;
PROCEDURE -Init* (flags: SET): Integer "SDL_Init(flags)";

(* This procedure initializes specific SDL subsystems *)
PROCEDURE -SDL_InitSubSystem* (flags: SET): Integer;
PROCEDURE -InitSubSystem* (flags: SET): Integer
	"SDL_InitSubSystem(flags)";

(* This procedure cleans up specific SDL subsystems *)
PROCEDURE -SDL_QuitSubSystem* (flags: SET);
PROCEDURE -QuitSubSystem* (flags: SET) "SDL_QuitSubSystem(flags)";

(* This procedure returns mask of the specified subsystems which have
	been initialized.
	If 'flags' is 0, it returns a mask of all initialized subsystems. *)

PROCEDURE -SDL_WasInit* (flags: SET): SET;
PROCEDURE -WasInit* (flags: SET): SET "SDL_WasInit(flags)";

(* This procedure cleans up all initialized subsystems and unloads the
	dynamically linked library. You should call it upon all exit conditions. *)
PROCEDURE -SDL_Quit* ;
PROCEDURE -Quit* "SDL_Quit()";

(* This should be called from your WinMain() function, if any *)
PROCEDURE -SDL_RegisterApp* (
	name: PChar; style: UInt32; hInst: Pointer): Integer;
PROCEDURE -RegisterApp* (
	name: PChar; style: UInt32; hInst: Pointer): Integer
	"SDL_RegisterApp(name, style, hInst)";
(*
{$IFDEF __MACH__}
// This should be called from your main() function, if any
PROCEDURE -InitQuickDraw* ["SDL_InitQuickDraw"] (theQd: QDGlobals);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name ''{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_InitQuickDraw}
{$ENDIF}

*)
(*----------------------------------------------------------------------------*)
(*																		Types																	 *)
(*----------------------------------------------------------------------------*)
(* The number of elements in a table *)
PROCEDURE -SDL_TableSize* (table: PChar): Integer;
PROCEDURE -TableSize* (table: PChar): Integer "SDL_TableSize(table)";


(*----------------------------------------------------------------------------*)
(*															 Error handling 															*)
(*----------------------------------------------------------------------------*)
(* Public functions *)
PROCEDURE -SDL_GetError* (): PChar;
PROCEDURE -GetError* (): PChar "SDL_GetError()";

PROCEDURE -SDL_SetError* (fmt: PChar);
PROCEDURE -SetError* (fmt: PChar) "SDL_SetError(fmt)";

PROCEDURE -SDL_ClearError* ;
PROCEDURE -ClearError* "SDL_ClearError()";
(* $IFNDEF WINDOWS}
PROCEDURE -SDL_Error(Code: TSDL_errorcode);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_Error'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_Error}
{$ENDIF*)

(* Private error message procedure - used internally *)
PROCEDURE -SDL_OutOfMemory* ;
PROCEDURE -OutOfMemory* "SDL_OutOfMemory()";

(*----------------------------------------------------------------------------*)
(*																IO handling 																*)
(*----------------------------------------------------------------------------*)

(* Functions to create SDL_RWops structures from various data sources *)

PROCEDURE -SDL_RWFromFile* (fileName, mode: PChar): PRWops;
PROCEDURE -RWFromFile* (fileName, mode: PChar): PRWops
	"SDL_RWFromFile(fileName, mode)";

PROCEDURE -SDL_FreeRW* (area: PRWops);
PROCEDURE -FreeRW* (area: PRWops) "SDL_FreeRW(area)";

(* fp is FILE *fp ??? *)
PROCEDURE -SDL_RWFromFP* (fp: Pointer; autoClose: Integer): PRWops;
PROCEDURE -RWFromFP* (fp: Pointer; autoClose: Integer): PRWops
	"SDL_RWFromFP(fp, autoClose)";

PROCEDURE -SDL_RWFromMem* (mem: Pointer; size: Integer): PRWops;
PROCEDURE -RWFromMem* (mem: Pointer; size: Integer): PRWops
	"SDL_RWFromMem(mem, size)";

PROCEDURE -SDL_RWFromConstMem* (mem: Pointer; size: Integer): PRWops;
PROCEDURE -RWFromConstMem* (mem: Pointer; size: Integer): PRWops
	"SDL_RWFromConstMem(mem, size)";

PROCEDURE -SDL_AllocRW* (): PRWops;
PROCEDURE -AllocRW* (): PRWops "SDL_AllocRW()";

(*----------------------------------------------------------------------------*)
(*																Time handling 															*)
(*----------------------------------------------------------------------------*)

(* Get the number of milliseconds since the SDL library initialization. *)
(* Note that this value wraps if the program runs for more than ~49 days. *)
PROCEDURE -SDL_GetTicks* (): UInt32;
PROCEDURE -GetTicks* (): UInt32 "SDL_GetTicks()";

(* Wait a specified number of milliseconds before returning *)
PROCEDURE -SDL_Delay* (msec: Integer);
PROCEDURE -Delay* (msec: Integer) "SDL_Delay(msec)";

(* Add a new timer to the pool of timers already running. *)
(* Returns a timer ID, or NULL when an error occurs. *)
PROCEDURE -SDL_AddTimer* (
	interval: UInt32; callback: NewTimerCallback; param: Pointer): PTimerID;
PROCEDURE -AddTimer* (
	interval: UInt32; callback: NewTimerCallback; param: Pointer): PTimerID
	"SDL_AddTimer(interval, callback, param)";

(* Remove one of the multiple timers knowing its ID. *)
(* Returns a boolean value indicating success. *)
PROCEDURE -SDL_RemoveTimer* (t: PTimerID): Bool;
PROCEDURE -RemoveTimer* (t: PTimerID): Bool "SDL_RemoveTimer(t)";

PROCEDURE -SDL_SetTimer* (interval: UInt32; callback: TimerCallback): Integer;
PROCEDURE -SetTimer* (interval: UInt32; callback: TimerCallback): Integer
	"SDL_SetTimer(interval, callback)";

(*----------------------------------------------------------------------------*)
(*															 Audio routines 															*)
(*----------------------------------------------------------------------------*)

(* These functions are used internally, and should not be used unless you
	 have a specific need to specify the audio driver you want to use.
	 You should normally use SDL_Init() or SDL_InitSubSystem(). *)

PROCEDURE -SDL_AudioInit* (driverName: PChar): Integer;
PROCEDURE -AudioInit* (driverName: PChar): Integer "SDL_AudioInit(driverName)";

PROCEDURE -SDL_AudioQuit* ;
PROCEDURE -AudioQuit* "SDL_AudioQuit()";

(* This procedure fills the given character buffer with the name of the
	 current audio driver, and returns a Pointer to it if the audio driver has
	 been initialized.	It returns NULL if no driver has been initialized. *)

PROCEDURE -SDL_AudioDriverName* (nameBuf: PChar; maxLen: Integer): PChar;
PROCEDURE -AudioDriverName* (nameBuf: PChar; maxLen: Integer): PChar
	"SDL_AudioDriverName(nameBuf, maxLen)";

(* This procedure opens the audio device with the desired parameters, and
	 returns 0 if successful, placing the actual hardware parameters in the
	 structure pointed to by 'obtained'.	If 'obtained' is NULL, the audio
	 data passed to the callback procedure will be guaranteed to be in the
	 requested format, and will be automatically converted to the hardware
	 audio format if necessary.	This procedure returns -1 if it failed
	 to open the audio device, or couldn't set up the audio thread.

	 When filling in the desired audio spec structure,
		'desired->freq' should be the desired audio frequency in samples-per-second.
		'desired->format' should be the desired audio format.
		'desired->samples' is the desired size of the audio buffer, in samples.
			 This number should be a power of two, and may be adjusted by the audio
			 driver to a value more suitable for the hardware.	Good values seem to
			 range between 512 and 8096 inclusive, depending on the application and
			 CPU speed.	Smaller values yield faster response time, but can lead
			 to underflow if the application is doing heavy processing and cannot
			 fill the audio buffer in time.	A stereo sample consists of both right
			 and left channels in LR ordering.
			 Note that the number of samples is directly related to time by the
			 following formula:	ms = (samples*1000)/freq
		'desired->size' is the size in bytes of the audio buffer, and is
			 calculated by SDL_OpenAudio().
		'desired->silence' is the value used to set the buffer to silence,
			 and is calculated by SDL_OpenAudio().
		'desired->callback' should be set to a procedure that will be called
			 when the audio device is ready for more data.	It is passed a pointer
			 to the audio buffer, and the length in bytes of the audio buffer.
			 This procedure usually runs in a separate thread, and so you should
			 protect data structures that it accesses by calling SDL_LockAudio()
			 and SDL_UnlockAudio() in your code.
		'desired->userdata' is passed as the first parameter to your callback
			 function.

	 The audio device starts out playing silence when it's opened, and should
	 be enabled for playing by calling SDL_PauseAudio(0) when you are ready
	 for your audio callback procedure to be called.	Since the audio driver
	 may modify the requested size of the audio buffer, you should allocate
	 any local mixing buffers after you open the audio device. *)

PROCEDURE -SDL_OpenAudio* (desired, obtained: PAudioSpec): Integer;
PROCEDURE -OpenAudio* (desired, obtained: PAudioSpec): Integer
	"SDL_OpenAudio(desired, obtained)";

(* Get the current audio state: *)
PROCEDURE -SDL_GetAudioStatus* (): AudioStatus;
PROCEDURE -GetAudioStatus* (): AudioStatus "SDL_GetAudioStatus()";

(* This procedure pauses and unpauses the audio callback processing.
	 It should be called with a parameter of 0 after opening the audio
	 device to start playing sound.	This is so you can safely initialize
	 data for your callback procedure after opening the audio device.
	 Silence will be written to the audio device during the pause. *)

PROCEDURE -SDL_PauseAudio* (pauseOn: Integer);
PROCEDURE -PauseAudio* (pauseOn: Integer) "SDL_PauseAudio(pauseOn)";

(* This procedure loads a WAVE from the data source, automatically freeing
	 that source if 'freesrc' is non-zero.	For example, to load a WAVE file,
	 you could do:
	 SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);

	 If this procedure succeeds, it returns the given SDL_AudioSpec,
	 filled with the audio data format of the wave data, and sets
	 'audio_buf' to a malloc()'d buffer containing the audio data,
	 and sets 'audio_len' to the length of that audio buffer, in bytes.
	 You need to free the audio buffer with SDL_FreeWAV() when you are
	 done with it.

	 This procedure returns NULL and sets the SDL error message if the
	 wave file cannot be opened, uses an unknown data format, or is
	 corrupt.	Currently raw and MS-ADPCM WAVE files are supported. *)

PROCEDURE -SDL_LoadWAV_RW* (src: PRWops; freeSrc: Integer;
	spec: PAudioSpec; VAR audioBuf: UInt8; VAR audioLen: UInt32): PAudioSpec;
PROCEDURE -LoadWAV_RW* (src: PRWops; freeSrc: Integer;
	spec: PAudioSpec; VAR audioBuf: UInt8; VAR audioLen: UInt32): PAudioSpec
	"SDL_LoadWAV_RW(src, freeSrc, spec, audioBuf, audioLen)";

(* This procedure frees data previously allocated with SDL_LoadWAV_RW() *)

PROCEDURE -SDL_FreeWAV* (audioBuf: PUInt8);
PROCEDURE -FreeWAV* (audioBuf: PUInt8) "SDL_FreeWAV(audioBuf)";

(* This procedure takes a source format and rate and a destination format
	 and rate, and initializes the 'cvt' structure with information needed
	 by SDL_ConvertAudio() to convert a buffer of audio data from one format
	 to the other.
	 This procedure returns 0, or -1 if there was an error. *)
PROCEDURE -SDL_BuildAudioCVT* (
	cvt: PAudioCVT; srcFormat: UInt16; srcChannels: UInt8; srcRate: Integer;
	dstFormat: UInt16; dstChannels: UInt8; dstRate: Integer): Integer;
PROCEDURE -BuildAudioCVT* (
	cvt: PAudioCVT; srcFormat: UInt16; srcChannels: UInt8; srcRate: Integer;
	dstFormat: UInt16; dstChannels: UInt8; dstRate: Integer): Integer
	"SDL_BuildAudioCVT(cvt, srcFormat, srcChannels, srcRate, dstFormat, dstChannels, dstRate)";

(* Once you have initialized the 'cvt' structure using SDL_BuildAudioCVT(),
	 created an audio buffer cvt->buf, and filled it with cvt->len bytes of
	 audio data in the source format, this procedure will convert it in-place
	 to the desired format.
	 The data conversion may expand the size of the audio data, so the buffer
	 cvt->buf should be allocated after the cvt structure is initialized by
	 SDL_BuildAudioCVT(), and should be cvt->len*cvt->len_mult bytes long. *)
PROCEDURE -SDL_ConvertAudio* (cvt: PAudioCVT): Integer;
PROCEDURE -ConvertAudio* (cvt: PAudioCVT): Integer "SDL_ConvertAudio(cvt)";

(* This takes two audio buffers of the playing audio format and mixes
	 them, performing addition, volume adjustment, and overflow clipping.
	 The volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
	 for full audio volume.	Note this does not change hardware volume.
	 This is provided for convenience -- you can mix your own audio data. *)

PROCEDURE -SDL_MixAudio* (dst, src: PUInt8; len: UInt32; volume: Integer);
PROCEDURE -MixAudio* (dst, src: PUInt8; len: UInt32; volume: Integer)
	"SDL_MixAudio(dst, src, len, volume)";

(* The lock manipulated by these functions protects the callback function.
	 During a LockAudio/UnlockAudio pair, you can be guaranteed that the
	 callback procedure is not running.	Do not call these from the callback
	 procedure or you will cause deadlock. *)
PROCEDURE -SDL_LockAudio* ;
PROCEDURE -LockAudio* "SDL_LockAudio()";

PROCEDURE -SDL_UnlockAudio* ;
PROCEDURE -UnlockAudio* "SDL_UnlockAudio()";

(* This procedure shuts down audio processing and closes the audio device. *)

PROCEDURE -SDL_CloseAudio* ;
PROCEDURE -CloseAudio* "SDL_CloseAudio()";

(*----------------------------------------------------------------------------*)
(*																CD routines																 *)
(*----------------------------------------------------------------------------*)

(* Returns the number of CD-ROM drives on the system, or -1 if
	 SDL_Init() has not been called with the SDL_INIT_CDROM flag. *)

PROCEDURE -SDL_CDNumDrives* (): Integer;
PROCEDURE -CDNumDrives* (): Integer "SDL_CDNumDrives()";

(* Returns a human-readable, system-dependent identifier for the CD-ROM.
		Example:
		"/dev/cdrom"
		"E:"
		"/dev/disk/ide/1/master" *)

PROCEDURE -SDL_CDName* (drive: Integer): PChar;
PROCEDURE -CDName* (drive: Integer): PChar "SDL_CDName(drive)";

(* Opens a CD-ROM drive for access.	It returns a drive handle on success,
	 or NULL if the drive was invalid or busy.	This newly opened CD-ROM
	 becomes the default CD used when other CD functions are passed a NULL
	 CD-ROM handle.
	 Drives are numbered starting with 0. Drive 0 is the system default CD-ROM. *)

PROCEDURE -SDL_CDOpen* (drive: Integer): PCD;
PROCEDURE -CDOpen* (drive: Integer): PCD "SDL_CDOpen(drive)";

(* This procedure returns the current status of the given drive.
	 If the drive has a CD in it, the table of contents of the CD and current
	 play position of the CD will be stored in the SDL_CD structure. *)

PROCEDURE -SDL_CDStatus* (cdRom: PCD): CDstatus;
PROCEDURE -CDStatus* (cdRom: PCD): CDstatus "SDL_CDStatus(cdRom)";

(* Play the given CD starting at 'start_track' and 'start_frame' for 'ntracks'
	 tracks and 'nframes' frames.	If both 'ntrack' and 'nframe' are 0, play
	 until the end of the CD.	This procedure will skip data tracks.
	 This procedure should only be called after calling SDL_CDStatus() to
	 get track information about the CD.

	 For example:
	 // Play entire CD:
	if ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) then
		SDL_CDPlayTracks(cdrom, 0, 0, 0, 0);
	 // Play last track:
	 if ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) then
	 begin
		SDL_CDPlayTracks(cdrom, cdrom->numtracks-1, 0, 0, 0);
	 end;

	 // Play first and second track and 10 seconds of third track:
	 if ( CD_INDRIVE(SDL_CDStatus(cdrom)) )
		SDL_CDPlayTracks(cdrom, 0, 0, 2, 10);

	 This procedure returns 0, or -1 if there was an error. *)

PROCEDURE -SDL_CDPlayTracks* (
	cdRom: PCD; startTrack, startFrame, nTracks, nFrames: Integer): Integer;
PROCEDURE -CDPlayTracks* (
	cdRom: PCD; startTrack, startFrame, nTracks, nFrames: Integer): Integer
	"SDL_CDPlayTracks(cdRom, startTrack, startFrame, nTracks, nFrames)";

(* Play the given CD starting at 'start' frame for 'length' frames.
	 It returns 0, or -1 if there was an error. *)

PROCEDURE -SDL_CDPlay* (cdRom: PCD; start, length: Integer): Integer;
PROCEDURE -CDPlay* (cdRom: PCD; start, length: Integer): Integer
	"SDL_CDPlay(cdRom, start, length)";

(* Pause play -- returns 0, or -1 on error *)
PROCEDURE -SDL_CDPause* (cdRom: PCD): Integer;
PROCEDURE -CDPause* (cdRom: PCD): Integer "SDL_CDPause(cdRom)";

(* Resume play -- returns 0, or -1 on error *)
PROCEDURE -SDL_CDResume* (cdRom: PCD): Integer;
PROCEDURE -CDResume* (cdRom: PCD): Integer "SDL_CDResume(cdRom)";

(* Stop play -- returns 0, or -1 on error *)
PROCEDURE -SDL_CDStop* (cdRom: PCD): Integer;
PROCEDURE -CDStop* (cdRom: PCD): Integer "SDL_CDStop(cdRom)";

(* Eject CD-ROM -- returns 0, or -1 on error *)
PROCEDURE -SDL_CDEject* (cdRom: PCD): Integer;
PROCEDURE -CDEject* (cdRom: PCD): Integer "SDL_CDEject(cdRom)";

(* Closes the handle for the CD-ROM drive *)
PROCEDURE -SDL_CDClose* (cdRom: PCD);
PROCEDURE -CDClose* (cdRom: PCD) "SDL_CDClose(cdRom)";


(*----------------------------------------------------------------------------*)
(*															JoyStick routines 														*)
(*----------------------------------------------------------------------------*)

(* Count the number of joysticks attached to the system *)
PROCEDURE -SDL_NumJoysticks* (): Integer;
PROCEDURE -NumJoysticks* (): Integer "SDL_NumJoysticks()";

(* Get the implementation dependent name of a joystick.
	 This can be called before any joysticks are opened.
	 If no name can be found, this procedure returns NULL. *)
PROCEDURE -SDL_JoystickName* (index: Integer): PChar;
PROCEDURE -JoystickName* (index: Integer): PChar "SDL_JoystickName(index)";

(* Open a joystick for use - the index passed as an argument refers to
	 the N'th joystick on the system.	This index is the value which will
	 identify this joystick in future joystick events.

	 This procedure returns a joystick identifier, or NULL if an error occurred *)
PROCEDURE -SDL_JoystickOpen* (index: Integer): PJoystick;
PROCEDURE -JoystickOpen* (index: Integer): PJoystick
	"SDL_JoystickOpen(index)";

(* Returns 1 if the joystick has been opened, or 0 if it has not. *)
PROCEDURE -SDL_JoystickOpened* (index: Integer): Integer;
PROCEDURE -JoystickOpened* (index: Integer): Integer
	"SDL_JoystickOpened(index)";

(* Get the device index of an opened joystick. *)
PROCEDURE -SDL_JoystickIndex* (joystick: PJoystick): Integer;
PROCEDURE -JoystickIndex* (joystick: PJoystick): Integer
	"SDL_JoystickIndex(joystick)";

(* Get the number of general axis controls on a joystick *)
PROCEDURE -SDL_JoystickNumAxes* (joystick: PJoystick): Integer;
PROCEDURE -JoystickNumAxes* (joystick: PJoystick): Integer
	"SDL_JoystickNumAxes(joystick)";

(* Get the number of trackballs on a joystick
	 Joystick trackballs have only relative motion events associated
	 with them and their state cannot be polled. *)
PROCEDURE -SDL_JoystickNumBalls* (joystick: PJoystick): Integer;
PROCEDURE -JoystickNumBalls* (joystick: PJoystick): Integer
	"SDL_JoystickNumBalls(joystick)";

(* Get the number of POV hats on a joystick *)
PROCEDURE -SDL_JoystickNumHats* (joystick: PJoystick): Integer;
PROCEDURE -JoystickNumHats* (joystick: PJoystick): Integer
	"SDL_JoystickNumHats(joystick)";

(* Get the number of buttons on a joystick *)
PROCEDURE -SDL_JoystickNumButtons* (joystick: PJoystick): Integer;
PROCEDURE -JoystickNumButtons* (joystick: PJoystick): Integer
	"SDL_JoystickNumButtons(joystick)";

(* Update the current state of the open joysticks.
	 This is called automatically by the event loop if any joystick
	 events are enabled. *)

PROCEDURE -SDL_JoystickUpdate* ;
PROCEDURE -JoystickUpdate* "SDL_JoystickUpdate()";

(* Enable/disable joystick event polling.
	 If joystick events are disabled, you must call SDL_JoystickUpdate()
	 yourself and check the state of the joystick when you want joystick
	 information.
	 The state can be one of SDL_QUERY, SDL_ENABLE or SDL_IGNORE. *)

PROCEDURE -SDL_JoystickEventState* (state: Integer): Integer;
PROCEDURE -JoystickEventState* (state: Integer): Integer
	"SDL_JoystickEventState(state)";

(* Get the current state of an axis control on a joystick
	 The state is a value ranging from -32768 to 32767.
	 The axis indices start at index 0. *)

PROCEDURE -SDL_JoystickGetAxis* (joystick: PJoystick; axis: Integer): SInt16;
PROCEDURE -JoystickGetAxis* (joystick: PJoystick; axis: Integer): SInt16
	"SDL_JoystickGetAxis(joystick, axis)";

(* The hat indices start at index 0. *)

PROCEDURE -SDL_JoystickGetHat* (joystick: PJoystick; hat: Integer): UInt8;
PROCEDURE -JoystickGetHat* (joystick: PJoystick; hat: Integer): UInt8
	"SDL_JoystickGetHat(joystick, hat)";

(* Get the ball axis change since the last poll
	 This returns 0, or -1 if you passed it invalid parameters.
	 The ball indices start at index 0. *)

PROCEDURE -SDL_JoystickGetBall* (
	joystick: PJoystick; ball: Integer; VAR dx, dy: Integer): Integer;
PROCEDURE -JoystickGetBall* (
	joystick: PJoystick; ball: Integer; VAR dx, dy: Integer): Integer
	"SDL_JoystickGetBall(joystick, ball, dx, dy)";

(* Get the current state of a button on a joystick
	 The button indices start at index 0. *)
PROCEDURE -SDL_JoystickGetButton* (
	joystick: PJoystick; Button: Integer): UInt8;
PROCEDURE -JoystickGetButton* (joystick: PJoystick; Button: Integer): UInt8
	"SDL_JoystickGetButton(joystick, Button)";

(* Close a joystick previously opened with SDL_JoystickOpen() *)
PROCEDURE -SDL_JoystickClose* (joystick: PJoystick);
PROCEDURE -JoystickClose* (joystick: PJoystick) "SDL_JoystickClose(joystick)";


(*----------------------------------------------------------------------------*)
(*															 Event handling 															*)
(*----------------------------------------------------------------------------*)

(* Pumps the event loop, gathering events from the input devices.
	 This procedure updates the event queue and internal input device state.
	 This should only be run in the thread that sets the video mode. *)

PROCEDURE -SDL_PumpEvents* ;
PROCEDURE -PumpEvents* "SDL_PumpEvents()";

(* Checks the event queue for messages and optionally returns them.
	 If 'action' is SDL_ADDEVENT, up to 'numevents' events will be added to
	 the back of the event queue.
	 If 'action' is SDL_PEEKEVENT, up to 'numevents' events at the front
	 of the event queue, matching 'mask', will be returned and will not
	 be removed from the queue.
	 If 'action' is SDL_GETEVENT, up to 'numevents' events at the front
	 of the event queue, matching 'mask', will be returned and will be
	 removed from the queue.
	 This procedure returns the number of events actually stored, or -1
	 if there was an error.	This procedure is thread-safe. *)

PROCEDURE -SDL_PeepEvents* (VAR [nil] events: Event;
	numEvents: Integer; action: EventAction; mask: UInt32): Integer;
PROCEDURE -PeepEvents* (VAR [nil] events: Event;
	numEvents: Integer; action: EventAction; mask: UInt32): Integer
	"SDL_PeepEvents(events, numEvents, action, mask)";

(* Polls for currently pending events, and returns 1 if there are any pending
	 events, or 0 if there are none available.	If 'event' is not NULL, the next
	 event is removed from the queue and stored in that area. *)

PROCEDURE -SDL_PollEvent* (VAR [nil] event: Event): Integer;
PROCEDURE -PollEvent* (VAR [nil] event: Event): Integer "SDL_PollEvent(event)";

(* Waits indefinitely for the next available event, returning 1, or 0 if there
	 was an error while waiting for events.	If 'event' is not NULL, the next
	 event is removed from the queue and stored in that area. *)

PROCEDURE -SDL_WaitEvent* (VAR [nil] event: Event): Integer;
PROCEDURE -WaitEvent* (VAR [nil] event: Event): Integer "SDL_WaitEvent(event)";

PROCEDURE -SDL_PushEvent* (VAR [nil] event: Event): Integer;
PROCEDURE -PushEvent* (VAR [nil] event: Event): Integer "SDL_PushEvent(event)";

(* If the filter returns 1, then the event will be added to the internal queue.
	 If it returns 0, then the event will be dropped from the queue, but the
	 internal state will still be updated.	This allows selective filtering of
	 dynamically arriving events.

	 WARNING:	Be very careful of what you do in the event filter function, as
						 it may run in a different thread!

	 There is one caveat when dealing with the SDL_QUITEVENT event type.	The
	 event filter is only called when the window manager desires to close the
	 application window.	If the event filter returns 1, then the window will
	 be closed, otherwise the window will remain open if possible.
	 If the quit event is generated by an interrupt signal, it will bypass the
	 internal queue and be delivered to the application at the next event poll. *)
PROCEDURE -SDL_SetEventFilter* (filter: EventFilter);
PROCEDURE -SetEventFilter* (filter: EventFilter) "SDL_SetEventFilter(filter)";

(* Return the current event filter - can be used to "chain" filters.
	 If there is no event filter set, this procedure returns NULL. *)

PROCEDURE -SDL_GetEventFilter* (): EventFilter;
PROCEDURE -GetEventFilter* (): EventFilter "SDL_GetEventFilter()";

(* This procedure allows you to set the state of processing certain events.
	 If 'state' is set to SDL_IGNORE, that event will be automatically dropped
	 from the event queue and will not event be filtered.
	 If 'state' is set to SDL_ENABLE, that event will be processed normally.
	 If 'state' is set to SDL_QUERY, SDL_EventState() will return the
	 current processing state of the specified event. *)

PROCEDURE -SDL_EventState* (type: UInt8; state: Integer): UInt8;
PROCEDURE -EventState* (type: UInt8; state: Integer): UInt8
	"SDL_EventState(type, state)";


(*----------------------------------------------------------------------------*)
(*															Version routines															*)
(*----------------------------------------------------------------------------*)

(* This procedure gets the version of the dynamically linked SDL library.
	 it should NOT be used to fill a version structure, instead you should
	 use the SDL_Version() macro. *)

PROCEDURE -SDL_Linked_Version* (): PVersion;
PROCEDURE -Linked_Version* (): PVersion "SDL_Linked_Version()";

(*----------------------------------------------------------------------------*)
(*																		Video 																	*)
(*----------------------------------------------------------------------------*)

(* These functions are used internally, and should not be used unless you
	 have a specific need to specify the video driver you want to use.
	 You should normally use SDL_Init() or SDL_InitSubSystem().

	 SDL_VideoInit() initializes the video subsystem -- sets up a connection
	 to the window manager, etc, and determines the current video mode and
	 pixel format, but does not initialize a window or graphics mode.
	 Note that event handling is activated by this routine.

	 If you use both sound and video in your application, you need to call
	 SDL_Init() before opening the sound device, otherwise under Win32 DirectX,
	 you won't be able to set full-screen display modes. *)

PROCEDURE -SDL_VideoInit* (driverName: PChar; flags: SET): Integer;
PROCEDURE -VideoInit* (driverName: PChar; flags: SET): Integer
	"SDL_VideoInit(driverName, flags)";

PROCEDURE -SDL_VideoQuit* ;
PROCEDURE -VideoQuit* "SDL_VideoQuit()";

(* This procedure fills the given character buffer with the name of the
	 video driver, and returns a pointer to it if the video driver has
	 been initialized.	It returns NULL if no driver has been initialized. *)

PROCEDURE -SDL_VideoDriverName* (nameBuf: PChar; maxLen: Integer): PChar;
PROCEDURE -VideoDriverName* (nameBuf: PChar; maxLen: Integer): PChar
	"SDL_VideoDriverName(nameBuf, maxLen)";

(* This procedure returns a pointer to the current display surface.
	 If SDL is doing format conversion on the display surface, this
	 procedure returns the publicly visible surface, not the real video
	 surface. *)

PROCEDURE -SDL_GetVideoSurface* (): PSurface;
PROCEDURE -GetVideoSurface* (): PSurface "SDL_GetVideoSurface()";

(* This procedure returns a read-only pointer to information about the
	 video hardware.	If this is called before SDL_SetVideoMode(), the 'vfmt'
	 member of the returned structure will contain the pixel format of the
	 "best" video mode. *)
PROCEDURE -SDL_GetVideoInfo* (): PVideoInfo;
PROCEDURE -GetVideoInfo* (): PVideoInfo "SDL_GetVideoInfo()";

(* Check to see if a particular video mode is supported.
	 It returns 0 if the requested mode is not supported under any bit depth,
	 or returns the bits-per-pixel of the closest available mode with the
	 given width and height.	If this bits-per-pixel is different from the
	 one used when setting the video mode, SDL_SetVideoMode() will succeed,
	 but will emulate the requested bits-per-pixel with a shadow surface.

	 The arguments to SDL_VideoModeOK() are the same ones you would pass to
	 SDL_SetVideoMode() *)

PROCEDURE -SDL_VideoModeOK* (width, height, bpp: Integer; flags: SET): Integer;
PROCEDURE -VideoModeOK* (width, height, bpp: Integer; flags: SET): Integer
	"SDL_VideoModeOK(width, height, bpp, flags)";

(* Return a pointer to an array of available screen dimensions for the
	 given format and video flags, sorted largest to smallest.	Returns
	 NULL if there are no dimensions available for a particular format,
	 or (SDL_Rect ** )-1 if any dimension is okay for the given format.

	 if 'format' is NULL, the mode list will be for the format given
	 by SDL_GetVideoInfo( ) - > vfmt *)

PROCEDURE -SDL_ListModes* (
	format: PPixelFormat; flags: SET): PPRect (*Rect ** *) ;
PROCEDURE -ListModes* (
	format: PPixelFormat; flags: SET): PPRect (*Rect ** *)
	"SDL_ListModes(format, flags)";

(* Set up a video mode with the specified width, height and bits-per-pixel.

	 If 'bpp' is 0, it is treated as the current display bits per pixel.

	 If SDL_ANYFORMAT is set in 'flags', the SDL library will try to set the
	 requested bits-per-pixel, but will return whatever video pixel format is
	 available.	The default is to emulate the requested pixel format if it
	 is not natively available.

	 If SDL_HWSURFACE is set in 'flags', the video surface will be placed in
	 video memory, if possible, and you may have to call SDL_LockSurface()
	 in order to access the raw framebuffer.	Otherwise, the video surface
	 will be created in system memory.

	 If SDL_ASYNCBLIT is set in 'flags', SDL will try to perform rectangle
	 updates asynchronously, but you must always lock before accessing pixels.
	 SDL will wait for updates to complete before returning from the lock.

	 If SDL_HWPALETTE is set in 'flags', the SDL library will guarantee
	 that the colors set by SDL_SetColors() will be the colors you get.
	 Otherwise, in 8-bit mode, SDL_SetColors() may not be able to set all
	 of the colors exactly the way they are requested, and you should look
	 at the video surface structure to determine the actual palette.
	 If SDL cannot guarantee that the colors you request can be set,
	 i.e. if the colormap is shared, then the video surface may be created
	 under emulation in system memory, overriding the SDL_HWSURFACE flag.

	 If SDL_FULLSCREEN is set in 'flags', the SDL library will try to set
	 a fullscreen video mode.	The default is to create a windowed mode
	 if the current graphics system has a window manager.
	 If the SDL library is able to set a fullscreen video mode, this flag
	 will be set in the surface that is returned.

	 If SDL_DOUBLEBUF is set in 'flags', the SDL library will try to set up
	 two surfaces in video memory and swap between them when you call
	 SDL_Flip().	This is usually slower than the normal single-buffering
	 scheme, but prevents "tearing" artifacts caused by modifying video
	 memory while the monitor is refreshing.	It should only be used by
	 applications that redraw the entire screen on every update.

	 This procedure returns the video framebuffer surface, or NULL if it fails. *)

PROCEDURE -SDL_SetVideoMode* (
	width, height, bpp: Integer; flags: SET): PSurface;
PROCEDURE -SetVideoMode* (width, height, bpp: Integer; flags: SET): PSurface
	"SDL_SetVideoMode(width, height, bpp, flags)";

(* Makes sure the given list of rectangles is updated on the given screen.
	 If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire
	 screen.
	 These functions should not be called while 'screen' is locked. *)

PROCEDURE -SDL_UpdateRects* (
	screen: PSurface; numRects: Integer; rects: PRect);
PROCEDURE -UpdateRects* (screen: PSurface; numRects: Integer; rects: PRect)
	"SDL_UpdateRects(screen, numRects, rects)";

PROCEDURE -SDL_UpdateRect* (screen: PSurface; x, y: SInt32; w, h: UInt32);
PROCEDURE -UpdateRect* (screen: PSurface; x, y: SInt32; w, h: UInt32)
	"SDL_UpdateRect(screen, x, y, w, h)";

(* On hardware that supports double-buffering, this procedure sets up a flip
	 and returns.	The hardware will wait for vertical retrace, and then swap
	 video buffers before the next video surface blit or lock will return.
	 On hardware that doesn not support double-buffering, this is equivalent
	 to calling SDL_UpdateRect(screen, 0, 0, 0, 0);
	 The SDL_DOUBLEBUF flag must have been passed to SDL_SetVideoMode() when
	 setting the video mode for this procedure to perform hardware flipping.
	 This procedure returns 0 if successful, or -1 if there was an error. *)

PROCEDURE -SDL_Flip* (screen: PSurface): Integer;
PROCEDURE -Flip* (screen: PSurface): Integer "SDL_Flip(screen)";

(* Set the gamma correction for each of the color channels.
	 The gamma values range (approximately) between 0.1 and 10.0

	 If this procedure isn't supported directly by the hardware, it will
	 be emulated using gamma ramps, if available.	If successful, this
	 procedure returns 0, otherwise it returns -1. *)

PROCEDURE -SDL_SetGamma* (redGamma, greenGamma, blueGamma: Single): Integer;
PROCEDURE -SetGamma* (redGamma, greenGamma, blueGamma: Single): Integer
	"SDL_SetGamma(redGamma, greenGamma, blueGamma)";

(* Set the gamma translation table for the red, green, and blue channels
	 of the video hardware.	Each table is an array of 256 16-bit quantities,
	 representing a mapping between the input and output for that channel.
	 The input is the index into the array, and the output is the 16-bit
	 gamma value at that index, scaled to the output color precision.

	 You may pass NULL for any of the channels to leave it unchanged.
	 If the call succeeds, it will return 0.	If the display driver or
	 hardware does not support gamma translation, or otherwise fails,
	 this procedure will return -1. *)

PROCEDURE -SDL_SetGammaRamp* (
	redTable, greenTable, blueTable: PUInt16): Integer;
PROCEDURE -SetGammaRamp* (redTable, greenTable, blueTable: PUInt16): Integer
	"SDL_SetGammaRamp(redTable, greenTable, blueTable)";

(* Retrieve the current values of the gamma translation tables.

	 You must pass in valid pointers to arrays of 256 16-bit quantities.
	 Any of the pointers may be NULL to ignore that channel.
	 If the call succeeds, it will return 0.	If the display driver or
	 hardware does not support gamma translation, or otherwise fails,
	 this procedure will return -1. *)

PROCEDURE -SDL_GetGammaRamp* (
	redTable, greenTable, blueTable: PUInt16): Integer;
PROCEDURE -GetGammaRamp* (redTable, greenTable, blueTable: PUInt16): Integer
	"SDL_GetGammaRamp(redTable, greenTable, blueTable)";

(* Sets a portion of the colormap for the given 8-bit surface.	If 'surface'
	 is not a palettized surface, this procedure does nothing, returning 0.
	 If all of the colors were set as passed to SDL_SetColors(), it will
	 return 1.	If not all the color entries were set exactly as given,
	 it will return 0, and you should look at the surface palette to
	 determine the actual color palette.

	 When 'surface' is the surface associated with the current display, the
	 display colormap will be updated with the requested colors.	If
	 SDL_HWPALETTE was set in SDL_SetVideoMode() flags, SDL_SetColors()
	 will always return 1, and the palette is guaranteed to be set the way
	 you desire, even if the window colormap has to be warped or run under
	 emulation. *)

PROCEDURE -SDL_SetColors* (surface: PSurface;
	colors: PColor; firstColor: Integer; nColors: Integer): Integer;
PROCEDURE -SetColors* (surface: PSurface;
	colors: PColor; firstColor: Integer; nColors: Integer): Integer
	"SDL_SetColors(surface, colors, firstColor, nColors)";

(* Sets a portion of the colormap for a given 8-bit surface.
	 'flags' is one or both of:
	 SDL_LOGPAL	-- set logical palette, which controls how blits are mapped
									to/from the surface,
	 SDL_PHYSPAL -- set physical palette, which controls how pixels look on
									the screen
	 Only screens have physical palettes. Separate change of physical/logical
	 palettes is only possible if the screen has SDL_HWPALETTE set.

	 The return value is 1 if all colours could be set as requested, and 0
	 otherwise.

	 SDL_SetColors() is equivalent to calling this procedure with
	 flags = (SDL_LOGPAL or SDL_PHYSPAL). *)

PROCEDURE -SDL_SetPalette* (surface: PSurface;
	flags: SET; colors: PColor; firstColor: Integer; nColors: Integer): Integer;
PROCEDURE -SetPalette* (surface: PSurface;
	flags: SET; colors: PColor; firstColor: Integer; nColors: Integer): Integer
	"SDL_SetPalette(surface, flags, colors, firstColor, nColors)";

(* Maps an RGB triple to an opaque pixel value for a given pixel format *)
PROCEDURE -SDL_MapRGB* (format: PPixelFormat; r, g, b: UInt8): UInt32;
PROCEDURE -MapRGB* (format: PPixelFormat; r, g, b: UInt8): UInt32
	"SDL_MapRGB(format, r, g, b)";

(* Maps an RGBA quadruple to a pixel value for a given pixel format *)
PROCEDURE -SDL_MapRGBA* (format: PPixelFormat; r, g, b, a: UInt8): UInt32;
PROCEDURE -MapRGBA* (format: PPixelFormat; r, g, b, a: UInt8): UInt32
	"SDL_MapRGBA(format, r, g, b, a)";

(* Maps a pixel value into the RGB components for a given pixel format *)
PROCEDURE -SDL_GetRGB* (pixel: UInt32; fmt: PPixelFormat; VAR r, g, b: UInt8);
PROCEDURE -GetRGB* (pixel: UInt32; fmt: PPixelFormat; VAR r, g, b: UInt8)
	"SDL_GetRGB(pixel, fmt, r, g, b)";

(* Maps a pixel value into the RGBA components for a given pixel format *)
PROCEDURE -SDL_GetRGBA* (
	pixel: UInt32; fmt: PPixelFormat; VAR r, g, b, a: UInt8);
PROCEDURE -GetRGBA* (pixel: UInt32; fmt: PPixelFormat; VAR r, g, b, a: UInt8)
	"SDL_GetRGBA(pixel, fmt, r, g, b, a)";

(* Allocate and free an RGB surface (must be called after SDL_SetVideoMode)
	 If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
	 If the depth is greater than 8 bits, the pixel format is set using the
	 flags '[RGB]mask'.
	 If the procedure runs out of memory, it will return NULL.

	 The 'flags' tell what kind of surface to create.
	 SDL_SWSURFACE means that the surface should be created in system memory.
	 SDL_HWSURFACE means that the surface should be created in video memory,
	 with the same format as the display surface.	This is useful for surfaces
	 that will not change much, to take advantage of hardware acceleration
	 when being blitted to the display surface.
	 SDL_ASYNCBLIT means that SDL will try to perform asynchronous blits with
	 this surface, but you must always lock it before accessing the pixels.
	 SDL will wait for current blits to finish before returning from the lock.
	 SDL_SRCCOLORKEY indicates that the surface will be used for colorkey blits.
	 If the hardware supports acceleration of colorkey blits between
	 two surfaces in video memory, SDL will try to place the surface in
	 video memory. If this isn't possible or if there is no hardware
	 acceleration available, the surface will be placed in system memory.
	 SDL_SRCALPHA means that the surface will be used for alpha blits and
	 if the hardware supports hardware acceleration of alpha blits between
	 two surfaces in video memory, to place the surface in video memory
	 if possible, otherwise it will be placed in system memory.
	 If the surface is created in video memory, blits will be _much_ faster,
	 but the surface format must be identical to the video surface format,
	 and the only way to access the pixels member of the surface is to use
	 the SDL_LockSurface() and SDL_UnlockSurface() calls.
	 If the requested surface actually resides in video memory, SDL_HWSURFACE
	 will be set in the flags member of the returned surface.	If for some
	 reason the surface could not be placed in video memory, it will not have
	 the SDL_HWSURFACE flag set, and will be created in system memory instead. *)

PROCEDURE -SDL_CreateRGBSurface* (flags: SET; width, height, depth: Integer;
	rMask, gMask, bMask, aMask: UInt32): PSurface;
PROCEDURE -CreateRGBSurface* (flags: SET; width, height, depth: Integer;
	rMask, gMask, bMask, aMask: UInt32): PSurface
	"SDL_CreateRGBSurface(flags, width, height, depth, rMask, gMask, bMask, aMask)";
PROCEDURE -AllocSurface* (flags: SET; width, height, depth: Integer;
	rMask, gMask, bMask, aMask: UInt32): PSurface
	"SDL_CreateRGBSurface(flags, width, height, depth, rMask, gMask, bMask, aMask)";

PROCEDURE -SDL_CreateRGBSurfaceFrom* (
	pixels: Pointer; width, height, depth, pitch: Integer;
	rMask, gMask, bMask, aMask: UInt32): PSurface;
PROCEDURE -CreateRGBSurfaceFrom* (
	pixels: Pointer; width, height, depth, pitch: Integer;
	rMask, gMask, bMask, aMask: UInt32): PSurface
	"SDL_CreateRGBSurfaceFrom(pixels, width, height, depth, pitch, rMask, gMask, bMask, aMask)";

PROCEDURE -SDL_FreeSurface* (surface: PSurface);
PROCEDURE -FreeSurface* (surface: PSurface) "SDL_FreeSurface(surface)";

(* SDL_LockSurface() sets up a surface for directly accessing the pixels.
	 Between calls to SDL_LockSurface()/SDL_UnlockSurface(), you can write
	 to and read from 'surface->pixels', using the pixel format stored in
	 'surface->format'.	Once you are done accessing the surface, you should
	 use SDL_UnlockSurface() to release it.

	 Not all surfaces require locking.	If SDL_MUSTLOCK(surface) evaluates
	 to 0, then you can read and write to the surface at any time, and the
	 pixel format of the surface will not change.	In particular, if the
	 SDL_HWSURFACE flag is not given when calling SDL_SetVideoMode(), you
	 will not need to lock the display surface before accessing it.

	 No operating system or library calls should be made between lock/unlock
	 pairs, as critical system locks may be held during this time.

	 SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked. *)
PROCEDURE -SDL_LockSurface* (surface: PSurface): Integer;
PROCEDURE -LockSurface* (surface: PSurface): Integer
	"SDL_LockSurface(surface)";

PROCEDURE -SDL_UnlockSurface* (surface: PSurface);
PROCEDURE -UnlockSurface* (surface: PSurface) "SDL_UnlockSurface(surface)";

(* Load a surface from a seekable SDL data source (memory or file.)
	 If 'freesrc' is non-zero, the source will be closed after being read.
	 Returns the new surface, or NULL if there was an error.
	 The new surface should be freed with SDL_FreeSurface(). *)

PROCEDURE -SDL_LoadBMP_RW* (src: PRWops; freeSrc: Integer): PSurface;
PROCEDURE -LoadBMP_RW* (src: PRWops; freeSrc: Integer): PSurface
	"SDL_LoadBMP_RW(src, freeSrc)";

(* Save a surface to a seekable SDL data source (memory or file.)
	 If 'freedst' is non-zero, the source will be closed after being written.
	 Returns 0 if successful or -1 if there was an error. *)

PROCEDURE -SDL_SaveBMP_RW* (
	surface: PSurface; dst: PRWops; freeDst: Integer): Integer;
PROCEDURE -SaveBMP_RW* (
	surface: PSurface; dst: PRWops; freeDst: Integer): Integer
	"SDL_SaveBMP_RW(surface, dst, freeDst)";

(* Sets the color key (transparent pixel) in a blittable surface.
	 If 'flag' is SDL_SRCCOLORKEY (optionally OR'd with SDL_RLEACCEL),
	 'key' will be the transparent pixel in the source image of a blit.
	 SDL_RLEACCEL requests RLE acceleration for the surface if present,
	 and removes RLE acceleration if absent.
	 If 'flag' is 0, this procedure clears any current color key.
	 This procedure returns 0, or -1 if there was an error. *)

PROCEDURE -SDL_SetColorKey* (
	surface: PSurface; flag: SET; key: UInt32): Integer;
PROCEDURE -SetColorKey* (
	surface: PSurface; flag: SET; key: UInt32): Integer
	"SDL_SetColorKey(surface, flag, key)";

(* This procedure sets the alpha value for the entire surface, as opposed to
	 using the alpha component of each pixel. This value measures the range
	 of transparency of the surface, 0 being completely transparent to 255
	 being completely opaque. An 'alpha' value of 255 causes blits to be
	 opaque, the source pixels copied to the destination (the default). Note
	 that per-surface alpha can be combined with colorkey transparency.

	 If 'flag' is 0, alpha blending is disabled for the surface.
	 If 'flag' is SDL_SRCALPHA, alpha blending is enabled for the surface.
	 OR:ing the flag with SDL_RLEACCEL requests RLE acceleration for the
	 surface; if SDL_RLEACCEL is not specified, the RLE accel will be removed. *)

PROCEDURE -SDL_SetAlpha* (
	surface: PSurface; flag: SET; alpha: UInt8): Integer;
PROCEDURE -SetAlpha* (
	surface: PSurface; flag: SET; alpha: UInt8): Integer
	"SDL_SetAlpha(surface, flag, alpha)";

(* Sets the clipping rectangle for the destination surface in a blit.

	 If the clip rectangle is NULL, clipping will be disabled.
	 If the clip rectangle doesn't intersect the surface, the procedure will
	 return SDL_FALSE and blits will be completely clipped.	Otherwise the
	 procedure returns SDL_TRUE and blits to the surface will be clipped to
	 the intersection of the surface area and the clipping rectangle.

	 Note that blits are automatically clipped to the edges of the source
	 and destination surfaces. *)
PROCEDURE -SDL_SetClipRect* (surface: PSurface; VAR [nil] rect: Rect): Bool;
PROCEDURE -SetClipRect* (surface: PSurface; VAR [nil] rect: Rect): Bool
	"SDL_SetClipRect(surface, rect)";

(* Gets the clipping rectangle for the destination surface in a blit.
	 'rect' must be a pointer to a valid rectangle which will be filled
	 with the correct values. *)
PROCEDURE -SDL_GetClipRect* (surface: PSurface; VAR [nil] rect: Rect);
PROCEDURE -GetClipRect* (surface: PSurface; VAR [nil] rect: Rect)
	"SDL_GetClipRect(surface, rect)";

(* Creates a new surface of the specified format, and then copies and maps
	 the given surface to it so the blit of the converted surface will be as
	 fast as possible.	If this procedure fails, it returns NULL.

	 The 'flags' parameter is passed to SDL_CreateRGBSurface() and has those
	 semantics.	You can also pass SDL_RLEACCEL in the flags parameter and
	 SDL will try to RLE accelerate colorkey and alpha blits in the resulting
	 surface.

	 This procedure is used internally by SDL_DisplayFormat(). *)

PROCEDURE -SDL_ConvertSurface* (
	src: PSurface; fmt: PPixelFormat; flags: SET): PSurface;
PROCEDURE -ConvertSurface* (
	src: PSurface; fmt: PPixelFormat; flags: SET): PSurface
	"SDL_ConvertSurface(src, fmt, flags)";

(*
	This performs a fast blit from the source surface to the destination
	surface.	It assumes that the source and destination rectangles are
	the same size.	If either 'srcrect' or 'dstrect' are NULL, the entire
	surface (src or dst) is copied.	The final blit rectangles are saved
	in 'srcrect' and 'dstrect' after all clipping is performed.
	If the blit is successful, it returns 0, otherwise it returns -1.
 
	The blit procedure should not be called on a locked surface.
 
	The blit semantics for surfaces with and without alpha and colorkey
	are defined as follows:
 
	RGBA->RGB:
			SDL_SRCALPHA set:
	 alpha-blend (using alpha-channel).
	 SDL_SRCCOLORKEY ignored.
			SDL_SRCALPHA not set:
	 copy RGB.
	 if SDL_SRCCOLORKEY set, only copy the pixels matching the
	 RGB values of the source colour key, ignoring alpha in the
	 comparison.
 
	RGB->RGBA:
			SDL_SRCALPHA set:
	 alpha-blend (using the source per-surface alpha value);
	 set destination alpha to opaque.
			SDL_SRCALPHA not set:
	 copy RGB, set destination alpha to opaque.
			both:
	 if SDL_SRCCOLORKEY set, only copy the pixels matching the
	 source colour key.
 
	RGBA->RGBA:
			SDL_SRCALPHA set:
	 alpha-blend (using the source alpha channel) the RGB values;
	 leave destination alpha untouched. [Note: is this correct?]
	 SDL_SRCCOLORKEY ignored.
			SDL_SRCALPHA not set:
	 copy all of RGBA to the destination.
	 if SDL_SRCCOLORKEY set, only copy the pixels matching the
	 RGB values of the source colour key, ignoring alpha in the
	 comparison.
 
	RGB->RGB:
			SDL_SRCALPHA set:
	 alpha-blend (using the source per-surface alpha value).
			SDL_SRCALPHA not set:
	 copy RGB.
			both:
	 if SDL_SRCCOLORKEY set, only copy the pixels matching the
	 source colour key.
 
	If either of the surfaces were in video memory, and the blit returns -2,
	the video memory was lost, so it should be reloaded with artwork and
	re-blitted:
	while ( SDL_BlitSurface(image, imgrect, screen, dstrect) = -2 ) do
	begin
	while ( SDL_LockSurface(image) < 0 ) do
	 Sleep(10);
	-- Write image pixels to image->pixels --
	SDL_UnlockSurface(image);
 end;

	This happens under DirectX 5.0 when the system switches away from your
	fullscreen application.	The lock will also fail until you have access
	to the video memory again. *)

(* You should call SDL_BlitSurface() unless you know exactly how SDL
	 blitting works internally and how to use the other blit functions. *)

PROCEDURE -BlitSurface* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer
	"SDL_UpperBlit(src, srcRect, dst, dstRect)";

(* This is the public blit function, SDL_BlitSurface(), and it performs
	 rectangle validation and clipping before passing it to SDL_LowerBlit() *)
PROCEDURE -SDL_UpperBlit* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer;
PROCEDURE -UpperBlit* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer
	"SDL_UpperBlit(src, srcRect, dst, dstRect)";

(* This is a semi-private blit procedure and it performs low-level surface
	 blitting only. *)
PROCEDURE -SDL_LowerBlit* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer;
PROCEDURE -LowerBlit* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer
	"SDL_LowerBlit(src, srcRect, dst, dstRect)";

(* This procedure performs a fast fill of the given rectangle with 'color'
	 The given rectangle is clipped to the destination surface clip area
	 and the final fill rectangle is saved in the passed in pointer.
	 If 'dstrect' is NULL, the whole surface will be filled with 'color'
	 The color should be a pixel of the format used by the surface, and
	 can be generated by the SDL_MapRGB() function.
	 This procedure returns 0 on success, or -1 on error. *)

PROCEDURE -SDL_FillRect* (
	dst: PSurface; dstRect: PRect; color: UInt32): Integer;
PROCEDURE -FillRect* (
	dst: PSurface; dstRect: PRect; color: UInt32): Integer
	"SDL_FillRect(dst, dstRect, color)";

(* This procedure takes a surface and copies it to a new surface of the
	 pixel format and colors of the video framebuffer, suitable for fast
	 blitting onto the display surface.	It calls SDL_ConvertSurface()

	 If you want to take advantage of hardware colorkey or alpha blit
	 acceleration, you should set the colorkey and alpha value before
	 calling this function.

	 If the conversion fails or runs out of memory, it returns NULL *)

PROCEDURE -SDL_DisplayFormat* (surface: PSurface): PSurface;
PROCEDURE -DisplayFormat* (surface: PSurface): PSurface
	"SDL_DisplayFormat(surface)";

(* This procedure takes a surface and copies it to a new surface of the
	 pixel format and colors of the video framebuffer (if possible),
	 suitable for fast alpha blitting onto the display surface.
	 The new surface will always have an alpha channel.

	 If you want to take advantage of hardware colorkey or alpha blit
	 acceleration, you should set the colorkey and alpha value before
	 calling this function.

	 If the conversion fails or runs out of memory, it returns NULL *)

PROCEDURE -SDL_DisplayFormatAlpha* (surface: PSurface): PSurface;
PROCEDURE -DisplayFormatAlpha* (surface: PSurface): PSurface
	"SDL_DisplayFormatAlpha(surface)";

(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)
(* YUV video surface overlay functions																			 *)
(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)

(* This procedure creates a video output overlay
	 Calling the returned surface an overlay is something of a misnomer because
	 the contents of the display surface underneath the area where the overlay
	 is shown is undefined - it may be overwritten with the converted YUV data. *)

PROCEDURE -SDL_CreateYUVOverlay* (
	width, height: Integer; format: UInt32; display: PSurface): POverlay;
PROCEDURE -CreateYUVOverlay* (
	width, height: Integer; format: UInt32; display: PSurface): POverlay
	"SDL_CreateYUVOverlay(width, height, format, display)";

(* Lock an overlay for direct access, and unlock it when you are done *)
PROCEDURE -SDL_LockYUVOverlay* (overlay: POverlay): Integer;
PROCEDURE -LockYUVOverlay* (overlay: POverlay): Integer
	"SDL_LockYUVOverlay(overlay)";

PROCEDURE -SDL_UnlockYUVOverlay* (overlay: POverlay);
PROCEDURE -UnlockYUVOverlay* (overlay: POverlay)
	"SDL_UnlockYUVOverlay(overlay)";


(* Blit a video overlay to the display surface.
	 The contents of the video surface underneath the blit destination are
	 not defined.
	 The width and height of the destination rectangle may be different from
	 that of the overlay, but currently only 2x scaling is supported. *)

PROCEDURE -SDL_DisplayYUVOverlay* (
	overlay: POverlay; dstRect: PRect) : Integer;
PROCEDURE -DisplayYUVOverlay* (overlay: POverlay; dstRect: PRect) : Integer
	"SDL_DisplayYUVOverlay(overlay, dstRect)";

(* Free a video overlay *)
PROCEDURE -SDL_FreeYUVOverlay* (overlay: POverlay);
PROCEDURE -FreeYUVOverlay* (overlay: POverlay) "SDL_FreeYUVOverlay(overlay)";

(*----------------------------------------------------------------------------*)
(*															 OpenGL routines															*)
(*----------------------------------------------------------------------------*)

(* Dynamically load a GL driver, if SDL is built with dynamic GL.

	 SDL links normally with the OpenGL library on your system by default,
	 but you can compile it to dynamically load the GL driver at runtime.
	 If you do this, you need to retrieve all of the GL functions used in
	 your program from the dynamic library using SDL_GL_GetProcAddress().

	 This is disabled in default builds of SDL. *)

PROCEDURE -SDL_GL_LoadLibrary* (fileName: PChar): Integer;
PROCEDURE -GL_LoadLibrary* (fileName: PChar): Integer
	"SDL_GL_LoadLibrary(fileName)";

(* Get the address of a GL procedure (for extension functions) *)

PROCEDURE -SDL_GL_GetProcAddress* (procName: PChar): Address (*Pointer*) ;
PROCEDURE -GL_GetProcAddress* (procName: PChar): Address (*Pointer*)
	"SDL_GL_GetProcAddress(procName)";

(* Set an attribute of the OpenGL subsystem before intialization. *)

PROCEDURE -SDL_GL_SetAttribute* (attr: GLAttr; value: Integer): Integer;
PROCEDURE -GL_SetAttribute* (attr: GLAttr; value: Integer): Integer
	"SDL_GL_SetAttribute(attr, value)";

(* Get an attribute of the OpenGL subsystem from the windowing
	 interface, such as glX. This is of course different from getting
	 the values from SDL's internal OpenGL subsystem, which only
	 stores the values you request before initialization.

	 Developers should track the values they pass into SDL_GL_SetAttribute
	 themselves if they want to retrieve these values. *)

PROCEDURE -SDL_GL_GetAttribute* (attr: GLAttr; VAR value: Integer): Integer;
PROCEDURE -GL_GetAttribute* (attr: GLAttr; VAR value: Integer): Integer
	"SDL_GL_GetAttribute(attr, value)";

(* Swap the OpenGL buffers, if double-buffering is supported. *)

PROCEDURE -SDL_GL_SwapBuffers* ;
PROCEDURE -GL_SwapBuffers* "SDL_GL_SwapBuffers()";

(* Internal functions that should not be called unless you have read
	 and understood the source code for these functions. *)

PROCEDURE -SDL_GL_UpdateRects* (numRects: Integer; rects: PRect);
PROCEDURE -GL_UpdateRects* (numRects: Integer; rects: PRect)
	"SDL_GL_UpdateRects(numRects, rects)";

PROCEDURE -SDL_GL_Lock* ;
PROCEDURE -GL_Lock* "SDL_GL_Lock()";

PROCEDURE -SDL_GL_Unlock* ;
PROCEDURE -GL_Unlock* "SDL_GL_Unlock()";

(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)
(* These functions allow interaction with the window manager, if any.				*)
(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)

(* Sets/Gets the title and icon text of the display window *)

PROCEDURE -SDL_WM_GetCaption* (VAR title: PChar; VAR icon: PChar);
PROCEDURE -WM_GetCaption* (VAR title: PChar; VAR icon: PChar)
	"SDL_WM_GetCaption(title, icon)";

PROCEDURE -SDL_WM_SetCaption* (title, icon: PChar);
PROCEDURE -WM_SetCaption* (title, icon: PChar)
	"SDL_WM_SetCaption(title, icon)";

(* Sets the icon for the display window.
	 This procedure must be called before the first call to SDL_SetVideoMode().
	 It takes an icon surface, and a mask in MSB format.
	 If 'mask' is NULL, the entire icon surface will be used as the icon. *)

PROCEDURE -SDL_WM_SetIcon* (icon: PSurface; mask: UInt8);
PROCEDURE -WM_SetIcon* (icon: PSurface; mask: UInt8)
	"SDL_WM_SetIcon(icon, mask)";

(* This procedure iconifies the window, and returns 1 if it succeeded.
	 If the procedure succeeds, it generates an SDL_APPACTIVE loss event.
	 This procedure is a noop and returns 0 in non-windowed environments. *)

PROCEDURE -SDL_WM_IconifyWindow* (): Integer;
PROCEDURE -WM_IconifyWindow* (): Integer "SDL_WM_IconifyWindow()";

(* Toggle fullscreen mode without changing the contents of the screen.
	If the display surface does not require locking before accessing
	the pixel information, then the memory pointers will not change.

	If this procedure was able to toggle fullscreen mode (change from
	running in a window to fullscreen, or vice-versa), it will return 1.
	If it is not implemented, or fails, it returns 0.

	The next call to SDL_SetVideoMode() will set the mode fullscreen
	attribute based on the flags parameter - if SDL_FULLSCREEN is not
	set, then the display will be windowed by default where supported.

	This is currently only implemented in the X11 video driver. *)

PROCEDURE -SDL_WM_ToggleFullScreen* (surface: PSurface): Integer;
PROCEDURE -WM_ToggleFullScreen* (surface: PSurface): Integer
	"SDL_WM_ToggleFullScreen(surface)";

(* Grabbing means that the mouse is confined to the application window,
	 and nearly all keyboard input is passed directly to the application,
	 and not interpreted by a window manager, if any. *)

PROCEDURE -SDL_WM_GrabInput* (mode: GrabMode): GrabMode;
PROCEDURE -WM_GrabInput* (mode: GrabMode): GrabMode "SDL_WM_GrabInput(mode)";

(*----------------------------------------------------------------------------*)
(*															 Mouse routines 															*)
(*----------------------------------------------------------------------------*)

(* Retrieve the current state of the mouse.
	 The current button state is returned as a button bitmask, which can
	 be tested using the SDL_BUTTON(X) macros, and x and y are set to the
	 current mouse cursor position.	You can pass NULL for either x or y. *)

PROCEDURE -SDL_GetMouseState* (VAR x, y: Integer): UInt8;
PROCEDURE -GetMouseState* (VAR x, y: Integer): UInt8
	"SDL_GetMouseState(x, y)";

(* Retrieve the current state of the mouse.
	 The current button state is returned as a button bitmask, which can
	 be tested using the SDL_BUTTON(X) macros, and x and y are set to the
	 mouse deltas since the last call to SDL_GetRelativeMouseState(). *)
PROCEDURE -SDL_GetRelativeMouseState* (VAR x, y: Integer): UInt8;
PROCEDURE -GetRelativeMouseState* (VAR x, y: Integer): UInt8
	"SDL_GetRelativeMouseState(x, y)";

(* Set the position of the mouse cursor (generates a mouse motion event) *)
PROCEDURE -SDL_WarpMouse* (x, y: UInt16);
PROCEDURE -WarpMouse* (x, y: UInt16) "SDL_WarpMouse(x, y)";

(* Create a cursor using the specified data and mask (in MSB format).
	 The cursor width must be a multiple of 8 bits.

	 The cursor is created in black and white according to the following:
	 data	mask		resulting pixel on screen
	 	0		 1			 White
	 	1		 1			 Black
	 	0		 0			 Transparent
	 	1		 0			 Inverted color if possible, black if not.

	 Cursors created with this procedure must be freed with SDL_FreeCursor(). *)
PROCEDURE -SDL_CreateCursor* (
	data, mask: PUInt8; w, h, hotX, hotY: Integer): PCursor;
PROCEDURE -CreateCursor* (
	data, mask: PUInt8; w, h, hotX, hotY: Integer): PCursor
	"SDL_CreateCursor(data, mask, w, h, hotX, hotY)";

(* Set the currently active cursor to the specified one.
	 If the cursor is currently visible, the change will be immediately
	 represented on the display. *)
PROCEDURE -SDL_SetCursor* (cursor: PCursor);
PROCEDURE -SetCursor* (cursor: PCursor) "SDL_SetCursor(cursor)";

(* Returns the currently active cursor. *)
PROCEDURE -SDL_GetCursor* (): PCursor;
PROCEDURE -GetCursor* (): PCursor "SDL_GetCursor()";

(* Deallocates a cursor created with SDL_CreateCursor(). *)
PROCEDURE -SDL_FreeCursor* (cursor: PCursor);
PROCEDURE -FreeCursor* (cursor: PCursor) "SDL_FreeCursor(cursor)";

(* Toggle whether or not the cursor is shown on the screen.
	 The cursor start off displayed, but can be turned off.
	 SDL_ShowCursor() returns 1 if the cursor was being displayed
	 before the call, or 0 if it was not.	You can query the current
	 state by passing a 'toggle' value of -1. *)
PROCEDURE -SDL_ShowCursor* (toggle: Integer): Integer;
PROCEDURE -ShowCursor* (toggle: Integer): Integer "SDL_ShowCursor(toggle)";

(*----------------------------------------------------------------------------*)
(*															Keyboard routines														 *)
(*----------------------------------------------------------------------------*)

(* Enable/Disable UNICODE translation of keyboard input.
	 This translation has some overhead, so translation defaults off.
	 If 'enable' is 1, translation is enabled.
	 If 'enable' is 0, translation is disabled.
	 If 'enable' is -1, the translation state is not changed.
	 It returns the previous state of keyboard translation. *)
PROCEDURE -SDL_EnableUNICODE* (enable: Integer): Integer;
PROCEDURE -EnableUNICODE* (enable: Integer): Integer
	"SDL_EnableUNICODE(enable)";

(* If 'delay' is set to 0, keyboard repeat is disabled. *)
PROCEDURE -SDL_EnableKeyRepeat* (delay, interval: Integer): Integer;
PROCEDURE -EnableKeyRepeat* (delay, interval: Integer): Integer
	"SDL_EnableKeyRepeat(delay, interval)";

PROCEDURE -SDL_GetKeyRepeat* (VAR delay, interval: Integer);
PROCEDURE -GetKeyRepeat* (VAR delay, interval: Integer)
	"SDL_GetKeyRepeat(delay, interval)";

(* Get a snapshot of the current state of the keyboard.
	 Returns an array of keystates, indexed by the K_* syms.
	 Used:

	 UInt8 *keystate = SDL_GetKeyState(NULL);
	 if ( keystate[K_RETURN] ) ... <RETURN> is pressed *)

PROCEDURE -SDL_GetKeyState* (VAR numKeys: Integer): PUInt8;
PROCEDURE -GetKeyState* (VAR numKeys: Integer): PUInt8
	"SDL_GetKeyState(numKeys)";

(* Get the current key modifier state *)
PROCEDURE -SDL_GetModState* (): Mod;
PROCEDURE -GetModState* (): Mod "SDL_GetModState()";

(* Set the current key modifier state
	 This does not change the keyboard state, only the key modifier flags. *)
PROCEDURE -SDL_SetModState* (modState: Mod);
PROCEDURE -SetModState* (modState: Mod) "SDL_SetModState(modState)";

(* Get the name of an SDL virtual keysym *)
PROCEDURE -SDL_GetKeyName* (key: Key): PChar;
PROCEDURE -GetKeyName* (key: Key): PChar "SDL_GetKeyName(key)";

(*----------------------------------------------------------------------------*)
(*															Active routines 															*)
(*----------------------------------------------------------------------------*)

(* This procedure returns the current state of the application, which is a
	 bitwise combination of SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS, and
	 SDL_APPACTIVE.	If SDL_APPACTIVE is set, then the user is able to
	 see your application, otherwise it has been iconified or disabled. *)

PROCEDURE -SDL_GetAppState* (): UInt8;
PROCEDURE -GetAppState* (): UInt8 "SDL_GetAppState()";

(*
{ Mutex functions }

{ Create a mutex, initialized unlocked }

PROCEDURE -SDL_CreateMutex: PSDL_Mutex;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CreateMutex'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CreateMutex}

{ Lock the mutex	(Returns 0, or -1 on error) }

PROCEDURE -SDL_mutexP(mutex: PSDL_mutex): Integer;
 cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_mutexP'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{ $ EXTERNALSYM SDL_mutexP}

PROCEDURE -SDL_LockMutex(mutex: PSDL_mutex): Integer;
{-$EXTERNALSYM SDL_LockMutex}

{ Unlock the mutex	(Returns 0, or -1 on error) }
PROCEDURE -SDL_mutexV(mutex: PSDL_mutex): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_mutexV'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_mutexV}

PROCEDURE -SDL_UnlockMutex(mutex: PSDL_mutex): Integer;
{-$EXTERNALSYM SDL_UnlockMutex}

{ Destroy a mutex }
PROCEDURE -SDL_DestroyMutex(mutex: PSDL_mutex);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_DestroyMutex'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_DestroyMutex}

{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }
{ Semaphore functions																					 }
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }
{ Create a semaphore, initialized with value, returns NULL on failure. }
PROCEDURE -SDL_CreateSemaphore(initial_value: UInt32): PSDL_Sem;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CreateSemaphore'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CreateSemaphore}


{ Destroy a semaphore }
PROCEDURE -SDL_DestroySemaphore(sem: PSDL_sem);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_DestroySemaphore'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_DestroySemaphore}

{ This procedure suspends the calling thread until the semaphore pointed
	to by sem has a positive count. It then atomically decreases the semaphore
	count. }

PROCEDURE -SDL_SemWait(sem: PSDL_sem): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_SemWait'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_SemWait}

{ Non-blocking variant of SDL_SemWait(), returns 0 if the wait succeeds,
	 SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error. }

PROCEDURE -SDL_SemTryWait(sem: PSDL_sem): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_SemTryWait'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_SemTryWait}

{ Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
	 the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
	 the allotted time, and -1 on error.
	 On some platforms this procedure is implemented by looping with a delay
	 of 1 ms, and so should be avoided if possible. }

PROCEDURE -SDL_SemWaitTimeout(sem: PSDL_sem; ms: UInt32): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_SemWaitTimeout'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_SemTryWait}

{ Atomically increases the semaphore's count (not blocking), returns 0,
	 or -1 on error. }

PROCEDURE -SDL_SemPost(sem: PSDL_sem): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_SemPost'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_SemTryWait}

{ Returns the current count of the semaphore }

PROCEDURE -SDL_SemValue(sem: PSDL_sem): UInt32;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_SemValue'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_SemValue}

{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }
{ Condition variable functions																	}
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }
{ Create a condition variable }
PROCEDURE -SDL_CreateCond: PSDL_Cond;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CreateCond'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CreateCond}

{ Destroy a condition variable }
PROCEDURE -SDL_DestroyCond(cond: PSDL_Cond);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_DestroyCond'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_DestroyCond}

{ Restart one of the threads that are waiting on the condition variable,
	 returns 0 or -1 on error. }

PROCEDURE -SDL_CondSignal(cond: PSDL_cond): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CondSignal'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CondSignal}

{ Restart all threads that are waiting on the condition variable,
	returns 0 or -1 on error. }

PROCEDURE -SDL_CondBroadcast(cond: PSDL_cond): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CondBroadcast'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CondBroadcast}


{ Wait on the condition variable, unlocking the provided mutex.
	The mutex must be locked before entering this function!
	Returns 0 when it is signaled, or -1 on error. }

PROCEDURE -SDL_CondWait(cond: PSDL_cond; mut: PSDL_mutex): Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CondWait'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CondWait}

{ Waits for at most 'ms' milliseconds, and returns 0 if the condition
	variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
	signaled in the allotted time, and -1 on error.
	On some platforms this procedure is implemented by looping with a delay
	of 1 ms, and so should be avoided if possible. }

PROCEDURE -SDL_CondWaitTimeout(cond: PSDL_cond; mut: PSDL_mutex; ms: UInt32) : Integer;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CondWaitTimeout'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CondWaitTimeout}

{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }
{ Condition variable functions																	}
{ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * }

{ Create a thread }
PROCEDURE -SDL_CreateThread(fn: PInt; data: Pointer): PSDL_Thread;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_CreateThread'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_CreateThread}

{ Get the 32-bit thread identifier for the current thread }
PROCEDURE -SDL_ThreadID: UInt32;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_ThreadID'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_ThreadID}

{ Get the 32-bit thread identifier for the specified thread,
	equivalent to SDL_ThreadID() if the specified thread is NULL. }
PROCEDURE -SDL_GetThreadID(thread: PSDL_Thread): UInt32;
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_GetThreadID'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_GetThreadID}

{ Wait for a thread to finish.
	The return code for the thread procedure is placed in the area
	pointed to by 'status', if 'status' is not NULL. }

PROCEDURE -SDL_WaitThread(thread: PSDL_Thread; var status: Integer);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_WaitThread'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_WaitThread}

{ Forcefully kill a thread without worrying about its state }
PROCEDURE -SDL_KillThread(thread: PSDL_Thread);
cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_KillThread'{$ELSE} SDLLibName{$ENDIF __GPC__}{$ENDIF};
{-$EXTERNALSYM SDL_KillThread}

{------------------------------------------------------------------------------}
{ Get Environment Routines																										 }
{------------------------------------------------------------------------------}
{$IFDEF WINDOWS}
PROCEDURE -_putenv( const variable : Pchar ): integer;
cdecl;
{$ENDIF}

{$IFDEF Unix}
{$IFDEF FPC}
PROCEDURE -_putenv( const variable : Pchar ): integer;
cdecl; external 'libc.so' name 'putenv';
{$ENDIF}
{$ENDIF}

{ Put a variable of the form "name=value" into the environment }
//PROCEDURE -SDL_putenv(const variable: PChar): integer; cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_Init'{$ELSE} SDLLibName{$ENDIF __GPC__}SDLLibName name '';
PROCEDURE -SDL_putenv(const variable: PChar): integer;
{-$EXTERNALSYM SDL_putenv}

// The following procedure has been commented out to encourage developers to use
// SDL_putenv as it it more portable
//PROCEDURE -putenv(const variable: PChar): integer;
//{-$EXTERNALSYM putenv}

{$IFDEF WINDOWS}
{$IFNDEF __GPC__}
PROCEDURE -getenv( const name : Pchar ): PChar; cdecl;
{$ENDIF}
{$ENDIF}

{* Retrieve a variable named "name" from the environment }
//PROCEDURE -SDL_getenv(const name: PChar): PChar; cdecl; external {$IFNDEF NDS}{$IFDEF __GPC__}name 'SDL_Init'{$ELSE} SDLLibName{$ENDIF __GPC__}SDLLibName name '';
PROCEDURE -SDL_getenv(const name: PChar): PChar;
{-$EXTERNALSYM SDL_getenv}

// The following procedure has been commented out to encourage developers to use
// SDL_getenv as it it more portable
//PROCEDURE -getenv(const name: PChar): PChar;
//{-$EXTERNALSYM getenv}
*)
(*
 * This procedure gives you custom hooks into the window manager information.
 * It fills the structure pointed to by 'info' with custom information and
 * returns 1 if the procedure is implemented.	If it's not implemented, or
 * the version member of the 'info' structure is invalid, it returns 0.
 *)
PROCEDURE -SDL_GetWMInfo* (info: OS.PSysWMinfo): Integer;
PROCEDURE -GetWMInfo* (info: OS.PSysWMinfo): Integer "SDL_GetWMInfo(info)";

(*----------------------------------------------------------------------------*)

(* SDL_loadso.h *)
(* This procedure dynamically loads a shared object and returns a pointer
 * to the object handle (or NULL if there was an error).
 * The 'sofile' parameter is a system dependent name of the object file.
 *)
PROCEDURE -SDL_LoadObject* (soFile: PChar): Pointer;
PROCEDURE -LoadObject* (soFile: PChar): Pointer "SDL_LoadObject(soFile)";

(* Given an object handle, this procedure looks up the address of the
 * named procedure in the shared object and returns it.	This address
 * is no longer valid after calling SDL_UnloadObject().
 *)
PROCEDURE -SDL_LoadFunction* (handle: Pointer; name: PChar): Pointer;
PROCEDURE -LoadFunction* (handle: Pointer; name: PChar): Pointer
	"SDL_LoadFunction(handle, name)";

(* Unload a shared object from memory *)
PROCEDURE -SDL_UnloadObject* (handle: Pointer);
PROCEDURE -UnloadObject* (handle: Pointer) "SDL_UnloadObject(handle)";

(*----------------------------------------------------------------------------*)

PROCEDURE -MustLock* (surface: PSurface): BOOLEAN
	"(surface->offset || ((surface->flags & (0x00000001|0x00000004|0x00004000)) != 0))";

PROCEDURE -SDL_SoftStretch* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer;
PROCEDURE -SoftStretch* (
	src: PSurface; srcRect: PRect; dst: PSurface; dstRect: PRect): Integer
	"SDL_SoftStretch(src, srcRect, dst, dstRect)";

PROCEDURE -_init* "/*-noinit*/";

END SdlLib.

DevCompiler.CompileThis SdlLib(OS:Win32)
DevCompiler.CompileThis SdlLib(OS:Linux)